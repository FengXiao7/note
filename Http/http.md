# 传送门：

[开篇词｜To Be a HTTP Hero (geekbang.org)](https://time.geekbang.org/column/article/97822)

有机会再来深入体验下抓包流程。

老师讲的极为详细，很多知识作为前端人员没有必要掌握，了解即可。我会记录下我认为重要的地方。

这个课程，偏理论性会多一点，重要在于理解原理。实际使用的时候，应该不会直接操作头字段的，都有工具进行了封装的，比如请求方的axios，服务方的Nginx，都有相应的配置吧。(我的理解)



# 破冰期：

## 1.历史

1. HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；
2. HTTP/0.9 是个简单的文本协议，只能获取文本资源；
3. HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；
4. HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；
5. HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；
6. HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。

## 2.HTTP是什么？

先看一下 HTTP 的名字：**“超文本传输协议”**，它可以拆成三个部分，分别是：**“超文本”“传输”和“协议”**。我们从后往前来逐个解析，理解了这三个词，我们也就明白了什么是 HTTP。

![image-20220430175958106](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430175958106.png)

### 协议：

**HTTP 是一个用在计算机世界里的协议。**它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

### 传输：

HTTP 是一个**“传输协议”**，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A<===>B”。

#### HTTP 协议是一个“双向协议”。

也就是说，有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，数据在 A 和 B 之间双向而不是单向流动。通常我们把先发起传输动作的 A 叫做请求方，把后接到传输的 B 叫做应答方或者响应方。

#### 中转

数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。这样，传输方式就从“A<===>B”，变成了“A<=>X<=>Y<=>Z<=>B”，A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议。

**HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。**

### 超文本

所谓“**文本**”（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。

所谓“**超文本**”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。

**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**

### 总结：

**HTTP不是互联网、不是编程语言、不是HTML，不是一个孤立的协议**    

HTTP通常跑在TCP/IP协议栈之上，依靠IP实现寻址和路由、TCP协议实现可靠数据传输、DNS协议实现域名查找、SSL/TLS协议实现安全通信。此外，还有一些协议依赖于HTTP，例如WebSocket、HTTPDNS等。这些协议相互交织，构成了一个协议网，而HTTP则处于中心地位。

## 3.与HTTP相关的概念

### 浏览器

浏览器的正式名字叫“**Web Browser**”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。

浏览器本质上是一个 HTTP 协议中的**请求方**，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。

在 HTTP 协议里，浏览器的角色被称为“**User Agent”即“用户代理**”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“**客户端**”

### web服务器

刚才说的浏览器是 HTTP 里的请求方，那么在协议另一端的应答方（**响应方**）又是什么呢？这个你一定也很熟悉，答案就是服务器，Web Server。

**硬件含义**就是物理形式或“云”形式的**机器**，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。

**软件含义**的 Web 服务器可能我们更为关心，它就是**提供 Web 服务的应用程序**，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。

### CDN

浏览器和服务器是 HTTP 协议的两个端点，那么，在这两者之间还有别的什么东西吗？当然有了。**浏览器通常不会直接连到服务器**，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。

CDN，全称是“Content Delivery Network”，翻译过来就是“**内容分发网络**”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 有什么好处呢？简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接**在“半路”就可以获取响应**。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。

打个比方，就好像唐僧西天取经，刚出长安城，就看到阿难与迦叶把佛祖的真经递过来了，是不是很省事？

### 爬虫

前面说到过浏览器，它是一种用户代理，代替我们访问互联网。但 HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是**一种可以自动访问 Web 资源的应用程序**。

爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“**反爬虫**”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”**robots.txt**，约定哪些该爬，哪些不该爬。

## 4.与HTTP相关的协议

### TCP/IP

**TCP/IP 协议实际上是一系列网络通信协议的统称**，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。

这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：**TCP 属于“传输层”，IP 属于“网际层”**。

TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议**提供可靠的、字节流形式的通信**，是 HTTP 协议得以实现的基础。

HTTP 是一个"传输协议"，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“**HTTP over TCP/IP**”。

### DNS

“**域名系统**”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代。设想一下，你是愿意记“95.211.80.227”这样枯燥的数字，还是“nginx.org”这样的词组呢？

你想要打电话给小明，但不知道电话号码，就得在手机里的号码簿里一项一项地找，直到找到小明那一条记录，然后才能查到号码。这里的“小明”就相当于域名，而“电话号码”就相当于 IP 地址，这个查找的过程就是**域名解析**。

### URI/URL

URI（Uniform Resource Identifier），中文名称是 **统一资源标识符**，使用它就能够唯一地标记互联网上资源。

URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， **统一资源定位符**，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。

```
http://nginx.org/en/download.html
```

URI 主要有三个基本的部分构成：

- **协议名**：即访问该资源应当使用的协议，在这里是“http”；
- **主机名**：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；
- **路径**：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。

还是用打电话来做比喻，你通过电话簿找到了小明，让他把昨天做好的宣传文案快递过来。那么这个过程中你就完成了一次 URI 资源访问，“小明”就是“主机名”，“昨天做好的宣传文案”就是“路径”，而“快递”，就是你要访问这个资源的“协议名”。

### HTTPS

假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。有没有什么办法能够防止这种情况的发生呢？

确实有。你可以使用“加密”的方法，比如这样打电话：

```
你：“喂，小明啊，接下来我们改用火星文通话吧。”
小明：“好啊好啊，就用火星文吧。”
你：“巴拉巴拉巴拉巴拉……”
小明：“巴拉巴拉巴拉巴拉……”
```

如果你和小明说的火星文只有你们两个才懂，那么即使窃听到了这段谈话，他也不会知道你们到底在说什么，也就无从破坏你们的通话过程。HTTPS 就相当于这个比喻中的“火星文”，它的全称是“**HTTP over SSL/TLS**”，也就是运行在 SSL/TLS 协议上的 HTTP。

注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个**负责加密通信的安全协议**，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。 **HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”**

SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。

### 代理

代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，**既可以转发客户端的请求，也可以转发服务器的应答。**

代理有很多的种类，常见的有：

**匿名代理**：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；

**透明代理**：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；

**正向代理**：靠近客户端，代表客户端向服务器发送请求；

**反向代理**：靠近服务器端，代表服务器响应客户端的请求；



小强给小明打电话要小红的照片——小明是正向代理 

小强要小红的照片小明负责处理——小明是反向代理



由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：

**负载均衡**：把访问请求均匀分散到多台机器，实现访问集群化；

**内容缓存**：暂存上下行的数据，减轻后端的压力；

**安全防护**：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；

**数据处理**：提供压缩、加密等额外的功能。

### 总结：

网络通信是分布式系统的底座，也是信息交互的法宝 

TCP——负责数据传输 

IP——负责标识传输对象 

DNS——负责简化人类的记忆 

URI/L——负责标识传输的资源 

SSL——负责数据传输的安全

 Proxy——负责信息的中转

 像极了走标，

需要搞清楚从哪到哪——IP 

需要搞定怎么传输——TCP 

需要保障货物的安全——SSL 

需要送货的具体位置——URI 

需要把目的地的经纬度换成地址名——DNS 

需要中间中转一下——Proxy 

HTTP——我不那么多，我向你要什么你就给什么

## 5.分层

1、TCP/IP协议是一个“有层次的协议栈” TCP/IP 

2、TCP/IP协议总共有四层，顺序从下往上 链接层->网际层->传输层->应用层 

![image-20220430192930251](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430192930251.png)

3、链接层 link layer ，负责在底层网络上发送原始数据包，使用MAC地址来标记网络上的设备，所以也叫MAC层 

4、网际层 internet layer，IP协议所在层，在链接层的基础上，用IP地址取代MAC地址，把许多局域/广域网连接成虚拟的巨大网络，在这个网络里找设备时只要把IP地址再翻译成MAC地址就可以 

5、传输层 transport layer，TCP、UDP协议所在层，这个层次协议的职责是保证数据在IP地址标记的两点之间可靠地传输。 

6、TCP和UDP区别：    TCP 有状态 需要先建立连接才能发送数据       保证数据不丢失不重复        数据是连续的字节流，有先后顺序    UDP 无状态 不需要先建立连接也可以发送数据    不保证数据一定会发送到对方   数据是分散的小数据包，顺序发、乱序收 

7、应用层 application layer，Telnet、SSH、FTP、SMTP、HTTP  

8、MAC层的传输单位是帧（frame），IP层的传输单位是包（packet），TCP层的传输单位是段（segment），HTTP的传输单位是消息或报文（message）。统称为数据包

 9、OSI网络分层模型    

- 1.第一层:物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等;    
- 2.第二层:数据链路层，它基本相当于TCP/IP的链接层;    
- 3.第三层:网络层，相当于TCP/IP里的网际层;    
- 4.第四层:传输层，相当于TCP/IP里的传输层;   
-  5.第五层:会话层，维护网络中的连接状态，即保持会话和同步;   
-  6.第六层:表示层，把数据转换为合适、可理解的语法和语义;    
-  7.第七层:应用层，面向具体的应用传输数据。 

![image-20220430192957935](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430192957935.png)

10、TCP/IP四层模型和OSI七层网络模型的映射关系    

- 1.第一层:物理层，TCP/IP里无对应;    
- 2.第二层:数据链路层，对应TCP/IP的链接层;    
- 3.第三层:网络层，对应TCP/IP的网际层;    
- 4.第四层:传输层，对应TCP/IP的传输层;    
- 5.第五、六、七层:统一对应到TCP/IP的应用层。 

![image-20220430193016860](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430193016860.png)



**你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。**

假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。

你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。

接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。

之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。

快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。

这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。

![image-20220430193233186](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430193233186.png)

## 6.域名

- 域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；
- DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个“超级大管家”；
- DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；
- 使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。

## 7.搭建HTTP实验环境

***终有一天我会回来的！***

# 基础篇

## 08. 键入网址再按下回车，后面究竟发生了什么？

***推荐看原文***

在域名解析的过程中会有**多级的缓存**，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，也就是上一讲中我们修改的“C:\WINDOWS\system32\drivers\etc\hosts”



1.你能试着解释一下在浏览器里点击页面链接后发生了哪些事情吗？ 

浏览器点击页面请求后，正常网络中都是域名，那么浏览器会先用DNS解析一下，拿到服务器的ip和端口，去请求服务器前会先找一下缓存，浏览器自己的缓存-操作系统缓存-本地缓存（Hosts），都没有的话就会到根域名服务器-顶级-权威，当然中间可能有类似CDN这样的代理，那它就可以取CDN中的服务器地址，总的来说，其实就是个“走近道”的过程，就近原则，在DNS不错的情况下，先从离自己近的查起，再一级一级往下。 

2.这一节课里讲的都是正常的请求处理流程，如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？ 

如果是一个不存在的域名，那浏览器还是会从DNS那解析一下，发现，自己，操作系统，本地的缓存都没有，CDN里也没有，根域名，顶级域名，权威域名，非权威域名里 都没有，那它就放弃了，不会建立链接。因为dns解析失败，根本没有进入http处理流程，所以不会有4xx之类的错误，而是dns解析错误信息。

### 小结：

- HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；
- 如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败；
- 建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文； 
- 为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现“短路”操作；
- 虽然现实中的 HTTP 传输过程非常复杂，但理论上仍然可以简化成实验里的“两点”模型。

## 09 报文结构

### 报文

HTTP 协议的请求报文和响应报文的结构基本相同，

由三大部分组成：

**起始行**（start line）：描述请求或响应的基本信息；

**头部字段集合**（header）：使用 key-value 形式更详细地说明报文；

**消息正文**（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中**前两部分**起始行和头部字段经常又合称为“**请求头**”或“响应头”，消息正文又称为“**实体**”，但与“header”对应，很多时候就直接称为“**body**”。

HTTP 协议规定报文**必须有 header，但可以没有 body**，而且在 header 之后必须要有一个“**空行**”，也就是“CRLF”，十六进制的“0D0A”。

![image-20220519010309850](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010309850.png)

在很多时候，特别是浏览器发送 GET 请求的时候都是这样，HTTP 报文经常是只有 header 而没 body，相当于只发了一个超级“大头”过来，你可以想象的出来：每时每刻网络上都会有数不清的“大头儿子”在跑来跑去。

### 请求行

**简要地描述了客户端想要如何操作服务器端的资源。**

请求行由三部分构成：

**请求方法**：是一个动词，如 GET/POST，表示对资源的操作；

**请求目标**：通常是一个 URI，标记了请求方法要操作的资源；

**版本号**：表示报文使用的 HTTP 协议版本。这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

![image-20220519010609751](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010609751.png)

例子：**GET  /   HTTP/1.1**

在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”

### 状态行

看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），**意思是服务器响应的状态。**

比起请求行来说，状态行要简单一些，同样也是由三部分构成：

**版本号**：表示报文使用的 HTTP 协议版本；

**状态码**：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；

**原因**：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

![image-20220519010847412](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010847412.png)

例子：**HTTP/1.1   200   OK**

意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”

### 头部字段

![image-20220519011007519](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519011007519.png)

请求头和响应头的结构是基本一样的，**唯一的区别是起始行**

**头部字段是 key-value 的形式**，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。

比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。

### 常用头字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

**通用字段**：在请求头和响应头里都可以出现；

**请求字段**：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；

**响应字段**：仅能出现在响应头里，补充说明响应报文的信息；

**实体字段**：它实际上属于通用字段，但专门描述 body 的额外信息。

对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，**理解了头字段也就理解了 HTTP 报文。**



**Host 字段，它属于请求字段**，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求**必须出现**的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。

Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择。



**User-Agent 是请求字段**，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。

但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。



**Date 字段是一个通用字段**，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。



**Server 字段是响应字段**，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号。

Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。



**Content-Length是实体字段**，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。

### 小结：

- HTTP 报文结构就像是“大头儿子”，由“**起始行 + 头部 + 空行 + 实体**”组成，简单地说就是“header+body”；
- HTTP 报文可以没有 body，但**必须要有 header**，而且 **header 后也必须要有空行**，形象地说就是“大头”必须要带着“脖子”；
- 请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成；
- 请求行有三部分：请求方法，请求目标和版本号；
- 状态行也有三部分：版本号，状态码和原因字符串；
- 头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；
- HTTP/1.1 里唯一要求**必须提供的头字段是 Host**，它必须出现在请求头里，标记虚拟主机名。

## 10.请求头里的请求方法

需要有某种“动作的指示”，告诉操作资源的方式。所以，就这么出现了“请求方法”。它的实际含义就是**客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。**

目前 HTTP/1.1 规定了八种方法，**单词都必须是大写的形式**。

- GET：获取资源，可以理解为读取或者下载数据；
- HEAD：获取资源的元信息；
- POST：向资源提交数据，相当于写入或上传数据；
- PUT：类似 POST；
- DELETE：删除资源；
- CONNECT：建立特殊的连接隧道；
- OPTIONS：列出可对资源实行的方法；
- TRACE：追踪请求 - 响应的传输路径。

![image-20220519013625067](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519013625067.png)

### GET和HEAD：

**GET的含义是请求从服务器获取资源**，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。

**HEAD 方法与 GET 方法类似**，也是请求从服务器获取资源，服务器的处理机制也是一样的，但**服务器不会返回请求的实体数据，只会传回响应头**，也就是资源的“元信息”。

**HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”**。因为它的**响应头与 GET 完全相同**，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。



### POST和PUT

POST 和 PUT 方法则是相反操作，向 **URI 指定的资源提交数据，数据就放在报文的 body 里**。

POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，**只要向服务器发送数据，用的大多数都是 POST。**

PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 **POST 表示的是“新建”“create”的含义**，而 **PUT 则是“修改”“update”的含义**。在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。

### 其他方法

讲完了 GET/HEAD/POST/PUT，还剩下四个标准请求方法，它们属于比较“冷僻”的方法，应用的不是很多。

**DELETE 方法指示服务器删除资源**，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。

………………

### 扩展方法

虽然 HTTP/1.1 里规定了八种请求方法，但它**并没有限制我们只能用这八种方法**，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。

例如著名的愚人节玩笑 RFC2324，它定义了协议 HTCPCP，即“超文本咖啡壶控制协议”，为 HTTP 协议增加了用来煮咖啡的 BREW 方法，要求添牛奶的 WHEN 方法。(**好有意思！**)

如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 **LOCK** 方法锁定资源暂时不允许修改，或者使用 **PATCH** 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。

### 安全与幂等

在 HTTP 协议里，所谓的“安全”是指**请求方法不会“破坏”服务器上的资源**，即不会对服务器上的资源造成实质的修改。

按照这个定义，只有 **GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作**，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。

而 **POST/PUT/DELETE 操作会修改服务器上的资源**，增加或删除数据，所以是“**不安全**”的。



所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是**多次执行相同的操作，结果也都是相同的**，即多次“幂”后结果“相等”。

很显然，**GET 和 HEAD 既是安全的也是幂等的**，**DELETE** 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。

POST 是“**新增或提交数据**”，多次提交数据会创建多个资源，所以**不是幂等**的；

而 PUT 是“**替换或更新数据**”，多次更新一个资源，资源还是会第一次更新的状态，所以**是幂等**的。

我对你的建议是，你可以对比一下 SQL 来加深理解：把 **POST 理解成 INSERT，把 PUT 理解成 UPDATE**，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。



## 11.你能写出正确的网址吗？

URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。

![image-20220519152220217](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519152220217.png)



- URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；
- URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；
- scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；
- “host:port”表示资源所在的主机名和端口号；
- path 标记资源所在的位置；
- query 表示对资源附加的额外要求；
- 在 URI 里对“@&/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。

### 完整形态：

![image-20220522011122156](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220522011122156.png)

\#fragment由于只是浏览器的行为，所以不会发送到server，一些SPA也是利用这个特性来做本地的route管理。

## 12 响应状态码

RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。这五类的具体含义是：

- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
- 2××：成功，报文已经收到并被正确处理；
- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
- 4××：客户端错误，请求报文有误，服务器无法处理；
- 5××：服务器错误，服务器在处理请求时内部发生了错误。



### 1××

1××类状态码属于**提示信息**，是**协议处理的中间状态**，实际能够用到的时候很少。

### 2××

2××类状态码表示**服务器收到并成功处理了客户端的请求**，这也是客户端最愿意看到的状态码。

- “**200** OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。
- “**204** No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但**响应头后没有 body 数据**。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。
- “**206** Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“**范围请求**”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 **body 里的数据不是资源的全部，而是其中的一部分**。

### 3xx

3××类状态码表示**客户端请求的资源发生了变动**，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”

“**301** Moved Permanently”俗称“**永久重定向**”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。

“**302** Found”，曾经的描述短语是“Moved Temporarily”，俗称“**临时重定向**”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 **Location** 指明后续要跳转的 URI

“**304** Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“**重定向已到缓存的文件**”（即“缓存重定向”）。

### 4xx

4××类状态码表示**客户端发送的请求报文有误，服务器无法处理**，它就是真正的“错误码”含义了。

“**400** Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它**没有明确说，只是一个笼统的错误**

“**403** Forbidden”实际上不是客户端的请求出错，而是表示**服务器禁止访问资源**。原因可能多种多样，例如信息敏感、法律禁止等

“**404** Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是**资源在本服务器上未找到**，所以无法提供给客户端。

4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：

**405** Method Not Allowed：**不允许使用某些方法操作资源**，例如不允许 POST 只能 GET；

406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；

**408** Request Timeout：**请求超时，服务器等待了过长的时间**；

409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；

413 Request Entity Too Large：请求报文里的 body 太大；

414 Request-URI Too Long：请求行里的 URI 太大；

429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；

431 Request Header Fields Too Large：请求头某个字段或总体太大；



### 5××

5××类状态码表示**客户端请求报文正确**，但**服务器在处理时内部发生了错误**，无法返回应有的响应数据，是服务器端的“错误码”。

“**500** Internal Server Error”与 400 类似，也是一个通用的错误码，**服务器究竟发生了什么错误我们是不知道的**。

“**501** Not Implemented”表示**客户端请求的功能还不支持**，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。

“**502** Bad Gateway”通常是**服务器作为网关或者代理时返回的错误码**，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。

“**503** Service Unavailable”表示**服务器当前很忙，暂时无法响应服务**，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。503 是一个“**临时**”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“**Retry-After**”字段，指示客户端可以在多久以后再次尝试发送请求。

## 13.HTTP特点

***推荐看原文***

- HTTP 是**灵活可扩展**的，可以任意添加头字段实现任意功能；
- HTTP 是**可靠**传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
- HTTP 是**应用层协议**，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
- HTTP 使用了**请求 - 应答**模式，客户端主动发起请求，服务器被动回复请求；
- HTTP 本质上是**无状态**的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。

![image-20220519160838632](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519160838632.png)

## 14.HTTP优缺点

***推荐看原文***

- HTTP **最大的优点是简单、灵活和易于扩展**；
- HTTP 拥有**成熟的软硬件环境**，应用的非常广泛，是互联网的基础设施；
- HTTP 是**无状态**的，可以轻松实现集群化，扩展性能，但有时也需要用 **Cookie** 技术来实现“**有状态**”；
- HTTP 是**明文传输**，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
- HTTP 是**不安全**的，无法验证通信双方的身份，也不能判断报文是否被篡改；
- HTTP 的**性能不算差**，但不完全适应现在的互联网，还有很大的提升空间。

虽然 HTTP 免不了这样那样的缺点，但你也不要怕，别忘了它有一个最重要的“**灵活可扩展**”的优点，所有的缺点都可以在这个基础上想办法解决。

![image-20220522012727784](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220522012727784.png)

# 进阶篇

## 15.HTTP实体数据

### 数据类型与编码

传送门：[MIME笔记 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2008/06/mime.html)

HTTP用来标记body的数据类型，**MIME type**



MIME 把数据分成了**八大类**，每个大类下再细分出多个子类，形式是“**type/subtype**”的字符串

简单列举一下在 HTTP 里经常遇到的几个类别：

- **text**：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。
- **image**：即图像文件，有 image/gif、image/jpeg、image/png 等。
- **audio/video**：音频和视频数据，例如 audio/mpeg、video/mp4 等。
- **application**：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等



**Encoding type**，告诉数据是用的什么编码格式

比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：

- gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；
- deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；
- br：一种专门为 HTTP 优化的新压缩算法（Brotli）。

### 数据类型使用的头字段

HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“**内容协商**”。

也就是说，**客户端用 Accept 头**告诉服务器希望接收什么样的数据，而**服务器用 Content 头**告诉客户端实际发送了什么样的数据。

#### Accept和Content-Type

**Accept 字段标记的是客户端可理解的 MIME type**，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：

```
Accept: text/html,application/xml,image/webp,image/png
```

这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：

```
Content-Type: text/html
Content-Type: image/png
```

这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。

#### Accept-Encoding 和Content-Encoding

字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段 Content-Encoding 里。

```
Accept-Encoding: gzip, deflate, br
Content-Encoding: gzip
```

**不过这两个字段是可以省略的**，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。

### 语言类型与编码

“语言类型”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用“type-subtype”的形式，不过这里的格式与数据类型不同，**分隔符不是“/”，而是“-”。**

举几个例子：en 表示任意的英语，en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语。



### 语言类型使用的头字段

#### Accept-Language和Content-Language

Accept-Language 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：

```
Accept-Language: zh-CN, zh, en
```

这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。

相应的，服务器应该在响应报文里用头字段 Content-Language 告诉客户端实体数据使用的实际语言类型：

```
Content-Language: zh-CN
```

####  Accept-Charset和Content-Type

字符集在 HTTP 里使用的请求头字段是 Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“**charset=xxx**”来表示，这点需要特别注意。

例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样：

```
Accept-Charset: gbk, utf-8
Content-Type: text/html; charset=utf-8
```

不过现在的浏览器都支持多种字符集，通常**不会发送 Accept-Charset**，而服务器也**不会发送 Content-Language**，因为使用的语言完全可以由字符集推断出来，所以在**请求头**里一般只会有 **Accept-Language** 字段，**响应头**里只会有 **Content-Type** 字段。

![image-20220519170416645](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519170416645.png)

### 内容协商的质量值

在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。

**权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝**。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，**“;”的意义是小于“,”**的。例如下面的 Accept 字段：

```
Accept: text/html,application/xml;q=0.9,*/*;q=0.8
```

它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。



### 小结：

- **数据类型**表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；
- **数据编码**表示实体数据的**压缩方式**，相关的头字段是 Accept-Encoding 和 Content-Encoding；
- **语言类型**表示实体数据的**自然语言**，相关的头字段是 Accept-Language 和 Content-Language；
- **字符集**表示实体数据的**编码**方式，相关的头字段是 Accept-Charset 和 Content-Type；
- 客户端需要在请求头里使用 **Accept** 等头字段与服务器进行“**内容协商**”，要求服务器返回最合适的数据；
- Accept 等头字段可以用“,”顺序列出**多个可能**的选项，还可以用“;q=”参数来精确指定**权重**。

## 16.HTTP传输大文件的方法

### 数据压缩

通常浏览器在发送请求时都会带着“**Accept-Encoding**”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“**Content-Encoding**”响应头里，再把原数据压缩后发给浏览器。

不过这个解决方法也有个缺点，gzip 等压缩算法**通常只对文本文件有较好的压缩率**，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。

### 分块传输

如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。

“**化整为零**”的思路在 HTTP 协议里就是“**chunked**”分块传输编码，在响应报文里用头字段“**Transfer-Encoding: chunked**”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 **body 数据的长度是未知**的，无法在头字段“**Content-Length**”里给出确切的长度，所以也只能用 chunked 方式分块发送。

**“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的**，也就是说响应报文里这两个字段**不能同时出现**，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。

![image-20220522014740129](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220522014740129.png)

### 范围请求

你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。

HTTP 协议为了满足这样的需求，提出了“**范围请求**”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。

范围请求**不是 Web 服务器必备的功能**，可以实现也可以不实现，所以服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”。

如果不支持的话该怎么办呢？服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。

请求头 **Range** 是 HTTP 范围请求的专用字段，格式是“**bytes=x-y**”，其中的 x 和 y 是以字节为单位的数据范围。

***具体字段看原文吧，很详细***

### 多段数据

刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。

这种情况需要使用一种特殊的 MIME 类型：“**multipart/byteranges**”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记。

![image-20220519175400861](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519175400861.png)

### 小结

- 压缩 HTML 等文本文件是传输大文件最基本的方法；
- 分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；
- 范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；
- 也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。

要注意这四种方法不是互斥的，而是**可以混合起来使用**，例如压缩后再分块传输，或者分段后再分块

## 17.HTTP连接管理

### 短连接：

因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“**短连接**”（short-lived connections）。

短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。

![image-20220519193951214](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519193951214.png)

### 长连接：

针对短连接暴露出的缺点，HTTP 协议就提出了“**长连接**”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。

其实解决办法也很简单，用的就是“**成本均摊**”的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”**均摊**到多个“请求 - 应答”上。



![image-20220519194148857](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519194148857.png)

### 相关头字段

由于长连接对性能的改善效果非常显著，所以在 **HTTP/1.1 中的连接都会默认启用长连接**。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。

当然，我们也可以在请求头里明确地要求使用长连接机制，使用的字段是 **Connection**，值是“**keep-alive**”。

不过不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“**Connection: keep-alive**”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧”。

### 长连接缺点：

因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。

所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。在客户端，可以在请求头里加上“**Connection: close**”字段，告诉服务器：“这次通信后就关闭连接”。

### 队头阻塞

“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。

因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。

![image-20220519195203733](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519195203733.png)

### 性能优化

因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，有什么办法呢？

方案1： **并发连接**。“同时对一个域名发起多个长连接，用数量来解决质量的问题。”HTTP 允许客户端使用并发，但不能滥用。

方案2：“**域名分片**”。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 www.chrono.com。

### 小结

- 早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；
- HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；
- 服务器会发送“Connection: keep-alive”字段表示启用了长连接；
- 报文头里如果有“Connection: close”就意味着长连接即将关闭；
- 过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；
- “队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。

## 18.HTTP的重定向和跳转

我感觉了解即可

### 小结：

- 重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的；
- 301/302 是最常用的重定向状态码，分别是“永久重定向”和“临时重定向”；
- 响应头字段 Location 指示了要跳转的 URI，可以用绝对或相对的形式；
- 重定向可以把一个 URI 指向另一个 URI，也可以把多个 URI 指向同一个 URI，用途很多；
- 使用重定向时需要当心性能损耗，还要避免出现循环跳转。

## 19.HTTP的Cookie机制

怎么样让原本无“记忆能力”的服务器拥有“记忆能力”呢？

既然服务器记不住，那就在外部想办法记住。相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。

### Cookie 的工作过程

Cookie工作流程，需要用到响应头字段：**Set-Cookie**和请求头字段**Cookie** 

1. 客户端第一次请求时，没有cookie信息，服务器会创建一个独特的身份标识数据，格式是“key=value”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。
2. 客户端收到响应后，若Set-Cookie字段不为空，则将Cookie信息存在本地（一般是浏览器中），下一次请求时会将存储的Cookie信息放到头字段Cookie中发送给服务器，多个键值对中间用“;”隔开
3. 服务器再一次收到请求后，通过Cookie字段就能识别出该次请求的身份信息



不过因为服务器的“记忆能力”实在是太差，一张小纸条经常不够用。所以，服务器有时会在响应头里添加**多个 Set-Cookie**，存储多个“key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用“;”隔开就行。

![image-20220519202747477](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519202747477.png)

**Cookie 是由浏览器负责存储的**，而不是操作系统。所以，它是“浏览器绑定”的，**只能在本浏览器内生效**。

如果你换个浏览器或者换台电脑，新的浏览器里没有服务器对应的 Cookie，就好像是脱掉了贴着纸条的衣服，“健忘”的服务器也就认不出来了，只能再走一遍 Set-Cookie 流程。

### Cookie属性

Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息

#### 生存周期：

- “**Expires**”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。
- “**Max-Age**”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。
- Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。

案例：Expires 标记的过期时间是“GMT 2019 年 6 月 7 号 8 点 19 分”，而 Max-Age 则只有 10 秒，如果现在是 6 月 6 号零点，那么 Cookie 的实际有效期就是“6 月 6 号零点过 10 秒”

#### 作用域：

让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。

“**Domain**”和“**Path**”指定了 Cookie 所属的**域名和路径**，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。

#### 安全性：

- 属性“**HttpOnly**”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，“跨站脚本”（XSS）也就无从谈起了。
- 另一个属性“**SameSite**”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。



### Cookie的应用

Cookie 最基本的一个用途就是**身份识别**，保存用户的登录信息，实现会话事务。

Cookie 的另一个常见用途是**广告跟踪**。

### 小结：

- Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”；
- 响应报文使用 Set-Cookie 字段发送“key=value”形式的 Cookie 值；
- 请求报文里用 Cookie 字段发送多个 Cookie 值；
- 为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 等；
- Cookie 最基本的用途是身份识别，实现有状态的会话事务。

![image-20220519205051866](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519205051866.png)

## 20.HTTP的缓存控制

### 服务器的缓存控制（强制缓存）

例子：夏天到了，天气很热。你想吃西瓜消暑，于是打开冰箱，但很不巧，冰箱是空的。不过没事，现在物流很发达，给生鲜超市打个电话，不一会儿，就给你送来一个 8 斤的沙瓤大西瓜，上面还贴着标签：“保鲜期 5 天”。好了，你把它放进冰箱，想吃的时候随时拿出来。

在这个场景里，“生鲜超市”就是 Web 服务器，“你”就是浏览器，“冰箱”就是浏览器内部的缓存。整个流程翻译成 HTTP 就是：浏览器发现缓存无数据，于是发送请求，向服务器获取资源；服务器响应请求，返回资源，同时标记资源的有效期；浏览器缓存资源，等待下次重用。

![image-20220519210250761](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519210250761.png)

服务器标记资源有效期使用的头字段是“**Cache-Control**”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”

这里的 max-age 是“**生存时间**”。时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。



- **no-store**：**不允许缓存**，用于某些变化非常频繁的数据，例如秒杀页面；
- 例子：买来的西瓜不允许放进冰箱，要么立刻吃，要么立刻扔掉；
- **no-cache**：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是**可以缓存，但在使用之前必须要去服务器验证是否过期**，是否有最新的版本；
- 例子：可以放进冰箱，但吃之前必须问超市有没有更新鲜的，有就吃超市里的；
- **must-revalidate**：又是一个和 no-cache 相似的词，它的意思是**如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。**
- 例子：可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃。

![image-20220519210636178](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519210636178.png)

![image-20220430171930404](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430171930404.png)

### 客户端的缓存控制 

当你点“刷新”按钮的时候，浏览器会在请求头里加一个“**Cache-Control: max-age=0**”。

Ctrl+F5 的“强制刷新”又是什么样的呢？它其实是发了一个“**Cache-Control: no-cache**”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。

### 条件请求 （协商缓存）

![image-20220430172131041](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430172131041.png)

浏览器可以用两个连续的请求组成“验证动作”：先是一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存，节省网络流量，否则就再发一个 GET 请求，获取最新的版本。

但这样的两个请求网络成本太高了，所以 HTTP 协议就定义了一系列“**If**”开头的“**条件请求**”字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。

**条件请求**一共有 5 个头字段，我们最常用的是“**if-Modified-Since**（**保存资源的最后修改时间**）”和“**If-None-Match**（**保存资源唯一标识**）”这两个。对应的需要第一次的响应报文预先提供资源标识“**Last-modified**”和“**ETag**”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。不是就返回304，是就返回新的资源和新的资源标识。

##### 资源标识：

- 在 Response Headers 中，有两种。
- **Last-Modified**：资源的最后修改时间。
- **Etag**：资源的唯一标识（一个字符串，类似于人类的指纹）。

![image-20220430172305835](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430172305835.png)

服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。

##### Etag

![image-20220430172427595](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430172427595.png)

ETag 是“**实体标签**”（Entity Tag）的缩写，是**资源的一个唯一标识**，主要是用来解决修改时间无法准确区分文件变化的问题。

比如一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间（**Last-Modified**）就会误以为发生了变化，传送给浏览器就会浪费带宽。

**ETag 还有“强”“弱”之分。**

强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。







### 小结：

- 缓存是优化系统性能的重要手段，HTTP 传输的每一个环节中都可以有缓存；
- 服务器使用“Cache-Control”设置缓存策略，常用的是“max-age”，表示资源的有效期；
- 浏览器收到数据就会存入缓存，如果没过期就可以直接使用，过期就要去服务器验证是否仍然可用；
- 验证资源是否失效需要使用“条件请求”，常用的是“if-Modified-Since”和“If-None-Match”，收到 304 就可以复用缓存里的资源；
- 验证资源是否被修改的条件有两个：“Last-modified”和“ETag”，需要服务器预先在响应报文里设置，搭配条件请求使用；
- 浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷新数据。

### 作业：Catch和Cookie的异同

Cache 和 Cookie 的相同点是：都会保存到浏览器中，并可以设置过期时间。 

不同点： 

- Cookie 会随请求报文发送到服务器，而 Cache 不会，但可能会携带 if-Modified-Since（保存资源的最后修改时间）和 If-None-Match（保存资源唯一标识） 字段来验证资源是否过期。
- Cookie 在浏览器可以通过脚本获取（如果 cookie 没有设置 HttpOnly），Cache 则无法在浏览器中获取（出于安全原因）。 
- Cookie 通过响应报文的 Set-Cookie 字段获得，Cache缓存的是完整的报文。
-  用途不同。Cookie 常用于身份识别，Cache 则是由浏览器管理，用于节省带宽和加快响应速度。 
- Cookie 的 max-age 是从浏览器拿到响应报文时开始计算的，而 Cache 的 max-age 是从响应报文的生成时间（Date 头字段）开始计算。

## 21.HTTP的代理服务

![image-20220520172838797](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520172838797.png)

所谓的“**代理服务**”就是**指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份**：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求（**反向代理**）；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。（**正向代理**）

### Via

代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？

Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。

通过`Via`字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:

```
客户端 -> 代理1 -> 代理2 -> 源服务器
```

在源服务器收到请求后，会在`请求头`拿到这个字段:

```
Via: proxy_server1, proxy_server2
```

而源服务器响应时，最终在客户端会拿到这样的`响应头`:

```
Via: proxy_server2, proxy_server1
```

可以看到，`Via`中代理的顺序即为在 HTTP 传输中报文传达的顺序。



### X-Forwarded-For

字面意思就是`为谁转发`, 它记录的是**请求方**的`IP`地址

“Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是**请求方的 IP 地址**。

### X-Real-IP

是另一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录**最初的客户端的IP**。（和X-Forwarded-For不同喔）

相应的，还有`X-Forwarded-Host`和`X-Forwarded-Proto`，分别记录**客户端**(注意哦，不包括代理)的**域名**和**协议名**。

### 代理协议：

`X-Forwarded-For`这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从`客户端`到`代理1`，这个字段是客户端的 IP，从`代理1`到`代理2`，这个字段就变为了代理1的 IP。

但是这会产生两个问题:

1. 意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。
2. 在 HTTPS 通信加密的过程中，原始报文是不允许修改的。

由此产生了`代理协议`

***详细介绍推荐看老师原文***



### 小结：

- HTTP 代理就是客户端和服务器通信链路中的一个中间环节，为两端提供“代理服务”；
- 代理处于中间层，为 HTTP 处理增加了更多的灵活性，可以实现负载均衡、安全防护、数据过滤等功能；
- 代理服务器需要使用字段“Via”标记自己的身份，多个代理会形成一个列表；
- 如果想要知道客户端的真实 IP 地址，可以使用字段“X-Forwarded-For”和“X-Real-IP”；
- 专门的“代理协议”可以在不改动原始报文的情况下传递客户端的真实 IP。

## 22.HTTP的缓存代理

***我觉得理解即可，推荐看原文***

例子：

便利店作为超市的代理，生意非常红火，顾客和超市双方都对现状非常满意。但时间一长，超市发现还有进一步提升的空间，因为每次便利店接到顾客的请求后都要专车跑一趟超市，还是挺麻烦的。

干脆这样吧，给便利店配发一个大冰柜。水果海鲜什么的都可以放在冰柜里，只要产品在保鲜期内，就允许顾客直接从冰柜提货。这样便利店就可以一次进货多次出货，省去了超市之间的运输成本。

![image-20220520180214046](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520180214046.png)

### 源服务器的缓存控制

- 区分客户端上的缓存和代理上的缓存，可以使用两个新属性“**private**（**只能在客户端保存**）”和“**public**”。
- 缓存失效后的重新验证也要区分开（即使用条件请求“Last-modified”和“ETag”），“**must-revalidate**”是只要过期就必须回源服务器验证，而新的“**proxy-revalidate**”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。
- 缓存的生存时间可以使用新的“**s-maxage**”（s 是 share 的意思，注意 maxage 中间没有“-”），只限定在代理上能够存多久，而客户端仍然使用“max-age”。
- **no-transform**。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止这样做，不许“偷偷摸摸搞小动作”。

例子：

- 水果上贴着标签“**private, max-age=5**”。这就是说水果不能放进冷柜，必须直接给顾客，保鲜期 5 天，过期了还得去超市重新进货。
- 冻鱼上贴着标签“**public, max-age=5, s-maxage=10**”。这个的意思就是可以在冰柜里存 10 天，但顾客那里只能存 5 天，过期了可以来便利店取，只要在 10 天之内就不必再找超市。
- 排骨上贴着标签“**max-age=30, proxy-revalidate, no-transform**”。因为缓存默认是 public 的，那么它在便利店和顾客的冰箱里就都可以存 30 天，过期后便利店必须去超市进新货，而且不能擅自把“大排”改成“小排”。

![image-20220520204006669](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520204006669.png)

### 客户端的缓存控制

![image-20220520204344346](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520204344346.png)



### 小结：

- 计算机领域里最常用的性能优化手段是“时空转换”，也就是“时间换空间”或者“空间换时间”，HTTP 缓存属于后者；
- 缓存代理是增加了缓存功能的代理服务，缓存源服务器的数据，分发给下游的客户端；
- “Cache-Control”字段也可以控制缓存代理，常用的有“private”“s-maxage”“no-transform”等，同样必须配合“Last-modified”“ETag”等字段才能使用；
- 缓存代理有时候也会带来负面影响，缓存不良数据，需要及时刷新或删除。

# 安全篇

## 23.HTTPS是什么？SSL/TLS又是什么？

我曾经谈到过 HTTP 的一些缺点，其中的“**无状态**”在加入 Cookie 后得到了解决，而另两个缺点——“**明文**”和“**不安全**”仅凭 HTTP 自身是无力解决的，需要引入新的 HTTPS 协议。

### 什么是安全

如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：**机密性**、**完整性**，**身份认证**和**不可否认**。

- **机密性**（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。
- **完整性**（Integrity，也叫一致性）是指数据在传输过程中没有被篡改，不多也不少，“完完整整”地保持着原状。
- **身份认证**（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。
- **不可否认**（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。

### 什么是HTTPS

新的协议名“**https**”，默认端口号 **443**

也就是说，除了协议名“http”和端口号 80 这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。

HTTPS 名字里的“S”，它把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“**HTTP over TCP/IP**”变成了“**HTTP over SSL/TLS**”，让 HTTP 运行在了安全的 SSL/TLS 协议上（可参考第 4 讲和第 5 讲），收发报文不再使用 Socket API，而是调用专门的安全接口。

![image-20220520205556789](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520205556789.png)

### SSL/TLS

**SSL 即安全套接层**（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。SSL 发展到 v3 时已经证明了它自身是一个非常好的**安全通信协议**，于是互联网工程组 IETF 在 1999 年把它改名为 **TLS**（**传输层安全**，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 **TLS1.0 实际上就是 SSLv3.1**。

目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 **TLS1.2**。

### 密码套件

浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“**密码套件**”（cipher suite，也叫加密套件）。

TLS 的密码套件命名非常规范，格式很固定。基本的形式是“**密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法**”

例子：ECDHE-RSA-AES256-GCM-SHA384

“握手时使用 ECDHE 算法进行**密钥交换**，用 RSA **签名和身份认证**，握手后的通信使用 AES **对称算法**，密钥长度 256 位，**分组模式**是 GCM，**摘要算法** SHA384 用于消息认证和产生随机数。”



### 小结

- 因为 HTTP 是明文传输，所以不安全，容易被黑客窃听或篡改；
- 通信安全必须同时具备机密性、完整性、身份认证和不可否认这四个特性；
- HTTPS 的语法、语义仍然是 HTTP，但把下层的协议由 TCP/IP 换成了 SSL/TLS；
- SSL/TLS 是信息安全领域中的权威标准，采用多种先进的加密技术保证通信安全；
- **OpenSSL** 是著名的开源密码学工具包，是 SSL/TLS 的具体实现。

## 24.对称加密与非对称加密  （保证机密性）

“**加密**”（encrypt），就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊“钥匙”的人才能再转换出原始文本。这里的“钥匙”就叫做“**密钥**”（key），加密前的消息叫“**明文**”（plain text/clear text），加密后的乱码叫“**密文**”（cipher text），使用密钥还原明文的过程叫“**解密**”（decrypt），是加密的反操作，加密解密的操作过程就是“**加密算法**”。

由于 HTTPS、TLS 都运行在计算机上，所以“密钥”就是一长串的数字，但约定俗成的度量单位是“**位**”（bit），而不是“字节”（byte）。比如，说密钥长度是 128，就是 16 字节的二进制串

按照密钥的使用方式，加密可以分为两大类：**对称加密和非对称加密**。

### 对称加密

“对称加密”很好理解，就是指**加密和解密时使用的密钥都是同一个**，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。

![image-20220520211353054](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520211353054.png)

### 加密分组模式

对称算法还有一个“**分组模式**”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。<span style="color: red">（看不太懂……）</span>

例子：假设使用aes128，密钥长度是16字节，那么就把明文按16字节分组，然后每个分组用密钥加密

### 非对称加密

对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫“**密钥交换**”。

非对称加密（也叫**公钥加密算法**）。它有两个密钥，一个叫“**公钥**”（public key），一个叫“**私钥**”（private key）。两个密钥是不同的，“**不对称**”，公钥可以公开给任何人使用，而私钥必须严格保密。公钥和私钥有个特别的“**单向**”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。

![image-20220520212415860](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520212415860.png)

**RSA** 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“**整数分解**”的数学难题

**ECC**（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“**椭圆曲线离散对数**”的数学难题

### 混合加密

虽然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了**安全**，但**通信速度**有如乌龟、蜗牛，实用性就变成了零。

这就是现在 TLS 里使用的**混合加密**方式，其实说穿了也很简单：

<div style="color: red">（看不太懂……我觉得意思就是在对称算法的单个秘钥基础上用非对称算法再加密一遍秘钥，秘钥加密秘钥了属于）</div>

- 在通信刚开始的时候使用**非对称算法**，比如 RSA、ECDHE，首先解决**密钥交换**的问题。
- 然后用随机数产生对称算法使用的“**会话密钥**”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。
- 对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，**后续就不再使用非对称加密，全都使用对称加密。**

![image-20220520213707683](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520213707683.png)

### 小结：

- 加密算法的核心思想是“把一个小秘密（密钥）转化为一个大秘密（密文消息）”，守住了小秘密，也就守住了大秘密；
- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有 AES 和 ChaCha20；
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC；
- 把对称加密和非对称加密结合起来就得到了“又好又快”的混合加密，也就是 TLS 里使用的加密方式。

## 25.数字签名与证书

### 摘要算法 （保证完整性）

传送门：[数字签名是什么？ - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)

#### 概念

实现完整性的手段主要是**摘要算法**（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。

你可以把摘要算法近似地理解成一种**特殊的压缩算法**，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。

换一个角度，也可以把摘要算法理解成**特殊的“单向”加密算法**，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。

#### 常用算法

**MD5**（Message-Digest 5）、**SHA-1**（Secure Hash Algorithm 1），它们就是**最常用**的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的**安全强度比较低**，不够安全，在 TLS 里已经被**禁止使用**了。

TLS 推荐使用的是 SHA-1 的后继者：**SHA-2**

SHA-2 实际上是**一系列摘要算法的统称**，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

![image-20220520214839173](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520214839173.png)

### 完整性

摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。

不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。

所以，**真正的完整性必须要建立在机密性之上**，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。

![image-20220520215112939](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220520215112939.png)

### 数字签名 （保证“身份认证”和“不可否认”）

<span style="color: red">（数字签名就是用私钥加密原文的摘要）</span>



使用**私钥**再加上**摘要算法**，就能够实现“数字签名”，同时实现“**身份认证**”和“**不可否认**”。

数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是**私钥加密、公钥解密**。

但又因为非对称加密效率太低，所以**私钥只加密原文的摘要**，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。

例子：

你用自己的私钥**签名**一个消息“我是小明”。网站收到后用你的公钥**验签**，确认身份没问题，于是也用它的私钥签名消息“我是某宝”。你收到后再用它的公钥验一下，也没问题，这样你和网站就都知道对方不是假冒的，后面就可以用混合加密进行安全通信了

![image-20220521142343258](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220521142343258.png)

### 数字证书和 CA

<span style="color: red">（主要解决公钥的信任问题）</span>

***我感觉了解即可***

### 小结：

- 摘要算法用来实现完整性，能够为数据生成独一无二的“指纹”，常用的算法是 SHA-2；
- 数字签名是私钥对摘要的加密，可以由公钥解密后验证，实现身份认证和不可否认；
- 公钥的分发需要使用数字证书，必须由 CA 的信任链来验证，否则就是不可信的；
- 作为信任链的源头 CA 有时也会不可信，解决办法有 CRL、OCSP，还有终止信任。

## 26.TLS1.2连接过程解析

<span style="color: red">（极其复杂，可以看看原文，下面这篇文章也不错）</span>

传送门：[（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904100035821575#heading-76)

在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它**需要再用另外一个“握手”过程**，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。



![image-20220521152401587](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220521152401587.png)

第零阶段：TCP/IP 三次握手

第一阶段：**C/S两端共享Client Random、Server Random 和 Server Params信息** 

- 客户端--->服务器： 客户端的版本号、支持的密码套件，还有一个随机数（Client Random） 
- 服务端--->客户端： 客户端的版本号、选择的客户端列表的密码套件如：TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、随机数随机数（Server Random） 
- 服务端--->客户端： 服务端证书（Server Certificate）  
- 服务端--->客户端： 发送**Server Key Exchange**类型的请求，携带椭圆曲线的公钥（Server Params）用以实现密钥交换算法，另附私钥签名  
- 服务端--->客户端： 发送完毕 

 第二阶段：**证书验证** 

- 前验条件：客户端证书链逐级验证、证书公钥验证签名，服务端身份验证成功（证书合法） 
- 客户端--->服务端 发送**Client Key Exchange**类型的请求，携带椭圆曲线的公钥（Client Params）用以实现秘钥交换算法  

第三阶段：**主密钥生成** 

客户端、服务端分别使用Client Params、Server Params通过ECDHE算法计算出随机值**pre-master**，然后用 Client Random、Server Random 和 Pre-Master三个值作为原材料，用PRF伪随机数函数（利用密码套件的摘要算法再次强化结果 值maser secert的随机性）计算出主密钥**Master Secret**。

主密钥并不是会话秘钥，还会再用PRF扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）  

- 客户端--->服务端: 客户端发一个“**Change Cipher Spec**”，然后再发一个“**Finished**”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证. 
- 服务端--->客户端： 服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束.

### 小结

- HTTPS 协议会先与服务器执行 TCP 握手，然后执行 TLS 握手，才能建立安全连接；
- 握手的目标是安全地交换对称密钥，需要三个随机数，第三个随机数“Pre-Master”必须加密传输，绝对不能让黑客破解；
- “Hello”消息交换随机数，“Key Exchange”消息交换“Pre-Master”；
- “Change Cipher Spec”之前传输的都是明文，之后都是对称密钥加密的密文。

## 27.更好更快的握手：TLS1.3特性解析

<span style="color: red">（我感觉了解即可，推荐看看原文）</span>

### 小结：

- 为了兼容 1.1、1.2 等“老”协议，TLS1.3 会“伪装”成 TLS1.2，新特性在“扩展”里实现；
- 1.1、1.2 在实践中发现了很多安全隐患，所以 TLS1.3 大幅度删减了加密算法，只保留了 ECDHE、AES、ChaCha20、SHA-2 等极少数算法，强化了安全；
- TLS1.3 也简化了握手过程，完全握手只需要一个消息往返，提升了性能。

## 28.连接太慢该怎么办：HTTPS的优化

<span style="color: red">（我感觉了解即可，推荐看看原文）</span>

- 硬件优化
- 软件优化
- 协议优化
- 证书优化
- 会话复用

**会话复用**：我们再回想一下 HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”，不就可以免去了握手和计算的成本了吗？这种做法就叫“会话复用”

### 小结：

- 可以有多种硬件和软件手段减少网络耗时和计算耗时，让 HTTPS 变得和 HTTP 一样快，最可行的是软件优化；
- 应当尽量使用 ECDHE 椭圆曲线密码套件，节约带宽和计算量，还能实现“False Start”；
-  服务器端应当开启“OCSP Stapling”功能，避免客户端访问 CA 去验证证书；
- 会话复用的效果类似 Cache，前提是客户端必须之前成功建立连接，后面就可以用“Session ID”“Session Ticket”等凭据跳过密钥交换、证书验证等步骤，直接开始加密通信。

## 29. 我应该迁移到HTTPS吗？

<span style="color: red">（我感觉了解即可，老师教你在Nginx上怎么从http迁移到https。还有很多东西要学呀！）</span>

### 小结：

- 从 HTTP 迁移到 HTTPS 是“大势所趋”，能做就应该尽早做；
- 升级 HTTPS 首先要申请数字证书，可以选择免费好用的“Let’s Encrypt”；
- 配置 HTTPS 时需要注意选择恰当的 TLS 版本和密码套件，强化安全；
- 原有的 HTTP 站点可以保留作为过渡，使用 301 重定向到 HTTPS。

# 飞翔篇

## 23.HTTP/2特性概览

兼容 HTTP/1由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP/2 的唯一目标就是**改进性能**。

### 头部压缩

头部压缩背景

- http1的压缩只作用在body上，头部没有压缩 
- 头部携带了大量重复字段比如accept cookie，带宽浪费在了冗余度高的字段上
-  在get请求中，头部大，body小

HTTP/2压缩方法，HPACK算法，客户端和服务端建立字典，用索引表示重复的字符

### 二进制格式

不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用**二进制格式**。

它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“**打散**”为数个小片的**二进制“帧”**（Frame），用“**HEADERS**”帧存放头数据、“**DATA**”帧存放实体数据。

HTTP/2 数据分帧后“Header+Body”的报文结构就完全消失了，协议看到的只是一个个的“**碎片**”。

![image-20220521192324079](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220521192324079.png)







![image-20220521194001399](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220521194001399.png)



### 小结：

- HTTP 协议取消了小版本号，所以 HTTP/2 的正式名字不是 2.0；
- HTTP/2 在“语义”上兼容 HTTP/1，保留了请求方法、URI 等传统概念；
- HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；
- HTTP/2 的消息不再是“Header+Body”的形式，而是分散为多个二进制“帧”；
- HTTP/2 使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”，提高连接的利用率；
- HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件。

## 24.HTTP/2内核剖析

### 连接前言

TLS 握手成功之后，客户端必须要发送一个“**连接前言**”（connection preface），用来**确认建立 HTTP/2 连接**。

这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：

```
PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n
```

只要服务器收到这个“有魔力的字符串”，就知道客户端在 TLS 上想要的是 HTTP/2 协议



### 头部压缩

**HPACK**算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“**有状态**”的算法，需要客户端和服务器各自维护一份“**索引表**”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。



为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“**伪头字段**”（pseudo-header fields）。

为了与“真头字段”区分开来，这些**“伪头字段”会在名字前加一个“:”**，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。

HTTP/2 为一些最常用的头字段定义了一个只读的“**静态表**”（Static Table）。

![image-20220521201900072](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220521201900072.png)









### 小结：

- HTTP/2 必须先发送一个“连接前言”字符串，然后才能建立正式连接；
- HTTP/2 废除了起始行，统一使用头字段，在两端维护字段“Key-Value”的索引表，使用“HPACK”算法压缩头部；
- HTTP/2 把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；
- 流是 HTTP/2 虚拟的概念，是帧的双向传输序列，相当于 HTTP/1 里的一次“请求 - 应答”；
- 在一个 HTTP/2 连接上可以并发多个流，也就是多个“请求 - 响应”报文，这就是“多路复用”。

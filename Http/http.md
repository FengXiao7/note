# 传送门：

[开篇词｜To Be a HTTP Hero (geekbang.org)](https://time.geekbang.org/column/article/97822)

有机会再来深入体验下抓包流程。

老师讲的极为详细，很多知识作为前端人员没有必要掌握，我会记录下我认为重要的地方



# 破冰期：

## 1.历史

1. HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；
2. HTTP/0.9 是个简单的文本协议，只能获取文本资源；
3. HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；
4. HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；
5. HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；
6. HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。

## 2.HTTP是什么？

先看一下 HTTP 的名字：**“超文本传输协议”**，它可以拆成三个部分，分别是：**“超文本”“传输”和“协议”**。我们从后往前来逐个解析，理解了这三个词，我们也就明白了什么是 HTTP。

![image-20220430175958106](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430175958106.png)

### 协议：

**HTTP 是一个用在计算机世界里的协议。**它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

### 传输：

HTTP 是一个**“传输协议”**，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A<===>B”。

#### HTTP 协议是一个“双向协议”。

也就是说，有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，数据在 A 和 B 之间双向而不是单向流动。通常我们把先发起传输动作的 A 叫做请求方，把后接到传输的 B 叫做应答方或者响应方。

#### 中转

数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。这样，传输方式就从“A<===>B”，变成了“A<=>X<=>Y<=>Z<=>B”，A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议。

**HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。**

### 超文本

所谓“**文本**”（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。

所谓“**超文本**”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。

**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**

### 总结：

**HTTP不是互联网、不是编程语言、不是HTML，不是一个孤立的协议**    

HTTP通常跑在TCP/IP协议栈之上，依靠IP实现寻址和路由、TCP协议实现可靠数据传输、DNS协议实现域名查找、SSL/TLS协议实现安全通信。此外，还有一些协议依赖于HTTP，例如WebSocket、HTTPDNS等。这些协议相互交织，构成了一个协议网，而HTTP则处于中心地位。

## 3.与HTTP相关的概念

### 浏览器

浏览器的正式名字叫“**Web Browser**”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。

浏览器本质上是一个 HTTP 协议中的**请求方**，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。

在 HTTP 协议里，浏览器的角色被称为“**User Agent”即“用户代理**”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“**客户端**”

### web服务器

刚才说的浏览器是 HTTP 里的请求方，那么在协议另一端的应答方（**响应方**）又是什么呢？这个你一定也很熟悉，答案就是服务器，Web Server。

**硬件含义**就是物理形式或“云”形式的**机器**，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。

**软件含义**的 Web 服务器可能我们更为关心，它就是**提供 Web 服务的应用程序**，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。

### CDN

浏览器和服务器是 HTTP 协议的两个端点，那么，在这两者之间还有别的什么东西吗？当然有了。**浏览器通常不会直接连到服务器**，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。

CDN，全称是“Content Delivery Network”，翻译过来就是“**内容分发网络**”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 有什么好处呢？简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接**在“半路”就可以获取响应**。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。

打个比方，就好像唐僧西天取经，刚出长安城，就看到阿难与迦叶把佛祖的真经递过来了，是不是很省事？

### 爬虫

前面说到过浏览器，它是一种用户代理，代替我们访问互联网。但 HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是**一种可以自动访问 Web 资源的应用程序**。

爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“**反爬虫**”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”**robots.txt**，约定哪些该爬，哪些不该爬。

## 4.与HTTP相关的协议

### TCP/IP

**TCP/IP 协议实际上是一系列网络通信协议的统称**，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。

这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：**TCP 属于“传输层”，IP 属于“网际层”**。

TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议**提供可靠的、字节流形式的通信**，是 HTTP 协议得以实现的基础。

HTTP 是一个"传输协议"，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“**HTTP over TCP/IP**”。

### DNS

“**域名系统**”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代。设想一下，你是愿意记“95.211.80.227”这样枯燥的数字，还是“nginx.org”这样的词组呢？

你想要打电话给小明，但不知道电话号码，就得在手机里的号码簿里一项一项地找，直到找到小明那一条记录，然后才能查到号码。这里的“小明”就相当于域名，而“电话号码”就相当于 IP 地址，这个查找的过程就是**域名解析**。

### URI/URL

URI（Uniform Resource Identifier），中文名称是 **统一资源标识符**，使用它就能够唯一地标记互联网上资源。

URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， **统一资源定位符**，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。

```
http://nginx.org/en/download.html
```

URI 主要有三个基本的部分构成：

- **协议名**：即访问该资源应当使用的协议，在这里是“http”；
- **主机名**：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；
- **路径**：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。

还是用打电话来做比喻，你通过电话簿找到了小明，让他把昨天做好的宣传文案快递过来。那么这个过程中你就完成了一次 URI 资源访问，“小明”就是“主机名”，“昨天做好的宣传文案”就是“路径”，而“快递”，就是你要访问这个资源的“协议名”。

### HTTPS

假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。有没有什么办法能够防止这种情况的发生呢？

确实有。你可以使用“加密”的方法，比如这样打电话：

```
你：“喂，小明啊，接下来我们改用火星文通话吧。”
小明：“好啊好啊，就用火星文吧。”
你：“巴拉巴拉巴拉巴拉……”
小明：“巴拉巴拉巴拉巴拉……”
```

如果你和小明说的火星文只有你们两个才懂，那么即使窃听到了这段谈话，他也不会知道你们到底在说什么，也就无从破坏你们的通话过程。HTTPS 就相当于这个比喻中的“火星文”，它的全称是“**HTTP over SSL/TLS**”，也就是运行在 SSL/TLS 协议上的 HTTP。

注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个**负责加密通信的安全协议**，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。 **HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”**

SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。

### 代理

代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，**既可以转发客户端的请求，也可以转发服务器的应答。**

代理有很多的种类，常见的有：

**匿名代理**：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；

**透明代理**：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；

**正向代理**：靠近客户端，代表客户端向服务器发送请求；

**反向代理**：靠近服务器端，代表服务器响应客户端的请求；



小强给小明打电话要小红的照片——小明是正向代理 

小强要小红的照片小明负责处理——小明是反向代理



由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：

**负载均衡**：把访问请求均匀分散到多台机器，实现访问集群化；

**内容缓存**：暂存上下行的数据，减轻后端的压力；

**安全防护**：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；

**数据处理**：提供压缩、加密等额外的功能。

### 总结：

网络通信是分布式系统的底座，也是信息交互的法宝 

TCP——负责数据传输 

IP——负责标识传输对象 

DNS——负责简化人类的记忆 

URI/L——负责标识传输的资源 

SSL——负责数据传输的安全

 Proxy——负责信息的中转

 像极了走标，

需要搞清楚从哪到哪——IP 

需要搞定怎么传输——TCP 

需要保障货物的安全——SSL 

需要送货的具体位置——URI 

需要把目的地的经纬度换成地址名——DNS 

需要中间中转一下——Proxy 

HTTP——我不那么多，我向你要什么你就给什么

## 5.分层

1、TCP/IP协议是一个“有层次的协议栈” TCP/IP 

2、TCP/IP协议总共有四层，顺序从下往上 链接层->网际层->传输层->应用层 

![image-20220430192930251](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430192930251.png)

3、链接层 link layer ，负责在底层网络上发送原始数据包，使用MAC地址来标记网络上的设备，所以也叫MAC层 

4、网际层 internet layer，IP协议所在层，在链接层的基础上，用IP地址取代MAC地址，把许多局域/广域网连接成虚拟的巨大网络，在这个网络里找设备时只要把IP地址再翻译成MAC地址就可以 

5、传输层 transport layer，TCP、UDP协议所在层，这个层次协议的职责是保证数据在IP地址标记的两点之间可靠地传输。 

6、TCP和UDP区别：    TCP 有状态 需要先建立连接才能发送数据       保证数据不丢失不重复        数据是连续的字节流，有先后顺序    UDP 无状态 不需要先建立连接也可以发送数据    不保证数据一定会发送到对方   数据是分散的小数据包，顺序发、乱序收 

7、应用层 application layer，Telnet、SSH、FTP、SMTP、HTTP  

8、MAC层的传输单位是帧（frame），IP层的传输单位是包（packet），TCP层的传输单位是段（segment），HTTP的传输单位是消息或报文（message）。统称为数据包

 9、OSI网络分层模型    

- 1.第一层:物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等;    
- 2.第二层:数据链路层，它基本相当于TCP/IP的链接层;    
- 3.第三层:网络层，相当于TCP/IP里的网际层;    
- 4.第四层:传输层，相当于TCP/IP里的传输层;   
-  5.第五层:会话层，维护网络中的连接状态，即保持会话和同步;   
-  6.第六层:表示层，把数据转换为合适、可理解的语法和语义;    
-  7.第七层:应用层，面向具体的应用传输数据。 

![image-20220430192957935](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430192957935.png)

10、TCP/IP四层模型和OSI七层网络模型的映射关系    

- 1.第一层:物理层，TCP/IP里无对应;    
- 2.第二层:数据链路层，对应TCP/IP的链接层;    
- 3.第三层:网络层，对应TCP/IP的网际层;    
- 4.第四层:传输层，对应TCP/IP的传输层;    
- 5.第五、六、七层:统一对应到TCP/IP的应用层。 

![image-20220430193016860](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430193016860.png)

11、四层负载均衡：工作在传输层上，基于TCP/IP协议的特性，例如Ip地址，端口号等实现对后端服务器的负载均衡

12、七层负载均衡：工作在应用层上，看到的是HTTP协议，解析HTTP报文里的URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器

**你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。**

假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。

你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。

接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。

之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。

快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。

这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。

![image-20220430193233186](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430193233186.png)

## 6.域名

## 7.搭建HTTP实验环境

# 基础篇

## 08. 键入网址再按下回车，后面究竟发生了什么？

推荐看原文





1.你能试着解释一下在浏览器里点击页面链接后发生了哪些事情吗？ 

浏览器点击页面请求后，正常网络中都是域名，那么浏览器会先用DNS解析一下，拿到服务器的ip和端口，去请求服务器前会先找一下缓存，浏览器自己的缓存-操作系统缓存-本地缓存（Hosts），都没有的话就会到根域名服务器-顶级-权威，当然中间可能有类似CDN这样的代理，那它就可以取CDN中的服务器地址，总的来说，其实就是个“走近道”的过程，就近原则，在DNS不错的情况下，先从离自己近的查起，再一级一级往下。 

2.这一节课里讲的都是正常的请求处理流程，如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？ 

如果是一个不存在的域名，那浏览器还是会从DNS那解析一下，发现，自己，操作系统，本地的缓存都没有，CDN里也没有，根域名，顶级域名，权威域名，非权威域名里 都没有，那它就放弃了，不会建立链接。因为dns解析失败，根本没有进入http处理流程，所以不会有4xx之类的错误，而是dns解析错误信息。



## 09 报文结构

### 报文

HTTP 协议的请求报文和响应报文的结构基本相同，

由三大部分组成：

**起始行**（start line）：描述请求或响应的基本信息；

**头部字段集合**（header）：使用 key-value 形式更详细地说明报文；

**消息正文**（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中**前两部分**起始行和头部字段经常又合称为“**请求头**”或“响应头”，消息正文又称为“**实体**”，但与“header”对应，很多时候就直接称为“**body**”。

HTTP 协议规定报文**必须有 header，但可以没有 body**，而且在 header 之后必须要有一个“**空行**”，也就是“CRLF”，十六进制的“0D0A”。

![image-20220519010309850](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010309850.png)

在很多时候，特别是浏览器发送 GET 请求的时候都是这样，HTTP 报文经常是只有 header 而没 body，相当于只发了一个超级“大头”过来，你可以想象的出来：每时每刻网络上都会有数不清的“大头儿子”在跑来跑去。

### 请求行

**简要地描述了客户端想要如何操作服务器端的资源。**

请求行由三部分构成：

**请求方法**：是一个动词，如 GET/POST，表示对资源的操作；

**请求目标**：通常是一个 URI，标记了请求方法要操作的资源；

**版本号**：表示报文使用的 HTTP 协议版本。这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

![image-20220519010609751](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010609751.png)

例子：**GET  /   HTTP/1.1**

在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”

### 状态行

看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），**意思是服务器响应的状态。**

比起请求行来说，状态行要简单一些，同样也是由三部分构成：

**版本号**：表示报文使用的 HTTP 协议版本；

**状态码**：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；

**原因**：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

![image-20220519010847412](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010847412.png)

例子：**HTTP/1.1   200   OK**

意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”

### 头部字段

![image-20220519011007519](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519011007519.png)

请求头和响应头的结构是基本一样的，**唯一的区别是起始行**

**头部字段是 key-value 的形式**，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。

比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。

### 常用头字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

**通用字段**：在请求头和响应头里都可以出现；

**请求字段**：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；

**响应字段**：仅能出现在响应头里，补充说明响应报文的信息；

**实体字段**：它实际上属于通用字段，但专门描述 body 的额外信息。

对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，**理解了头字段也就理解了 HTTP 报文。**



**Host 字段，它属于请求字段**，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求**必须出现**的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。

Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择。



**User-Agent 是请求字段**，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。

但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。



**Date 字段是一个通用字段**，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。



**Server 字段是响应字段**，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号。

Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。



**Content-Length是实体字段**，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。

### 小结：

- HTTP 报文结构就像是“大头儿子”，由“**起始行 + 头部 + 空行 + 实体**”组成，简单地说就是“header+body”；
- HTTP 报文可以没有 body，但**必须要有 header**，而且 **header 后也必须要有空行**，形象地说就是“大头”必须要带着“脖子”；
- 请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成；
- 请求行有三部分：请求方法，请求目标和版本号；
- 状态行也有三部分：版本号，状态码和原因字符串；
- 头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；
- HTTP/1.1 里唯一要求**必须提供的头字段是 Host**，它必须出现在请求头里，标记虚拟主机名。

## 10.请求头里的请求方法

需要有某种“动作的指示”，告诉操作资源的方式。所以，就这么出现了“请求方法”。它的实际含义就是**客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。**

目前 HTTP/1.1 规定了八种方法，**单词都必须是大写的形式**。

- GET：获取资源，可以理解为读取或者下载数据；
- HEAD：获取资源的元信息；
- POST：向资源提交数据，相当于写入或上传数据；
- PUT：类似 POST；
- DELETE：删除资源；
- CONNECT：建立特殊的连接隧道；
- OPTIONS：列出可对资源实行的方法；
- TRACE：追踪请求 - 响应的传输路径。

![image-20220519013625067](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519013625067.png)

### GET和HEAD：

**GET的含义是请求从服务器获取资源**，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。

**HEAD 方法与 GET 方法类似**，也是请求从服务器获取资源，服务器的处理机制也是一样的，但**服务器不会返回请求的实体数据，只会传回响应头**，也就是资源的“元信息”。

**HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”**。因为它的**响应头与 GET 完全相同**，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。



### POST和PUT

POST 和 PUT 方法则是相反操作，向 **URI 指定的资源提交数据，数据就放在报文的 body 里**。

POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，**只要向服务器发送数据，用的大多数都是 POST。**

PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 **POST 表示的是“新建”“create”的含义**，而 **PUT 则是“修改”“update”的含义**。在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。

### 其他方法

讲完了 GET/HEAD/POST/PUT，还剩下四个标准请求方法，它们属于比较“冷僻”的方法，应用的不是很多。

**DELETE 方法指示服务器删除资源**，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。

………………

### 扩展方法

虽然 HTTP/1.1 里规定了八种请求方法，但它**并没有限制我们只能用这八种方法**，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。

例如著名的愚人节玩笑 RFC2324，它定义了协议 HTCPCP，即“超文本咖啡壶控制协议”，为 HTTP 协议增加了用来煮咖啡的 BREW 方法，要求添牛奶的 WHEN 方法。(好有意思！)

如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。

### 安全与幂等

在 HTTP 协议里，所谓的“安全”是指**请求方法不会“破坏”服务器上的资源**，即不会对服务器上的资源造成实质的修改。

按照这个定义，只有 **GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作**，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。

而 **POST/PUT/DELETE 操作会修改服务器上的资源**，增加或删除数据，所以是“**不安全**”的。



所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是**多次执行相同的操作，结果也都是相同的**，即多次“幂”后结果“相等”。

很显然，**GET 和 HEAD 既是安全的也是幂等的**，**DELETE** 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。

POST 是“**新增或提交数据**”，多次提交数据会创建多个资源，所以**不是幂等**的；

而 PUT 是“**替换或更新数据**”，多次更新一个资源，资源还是会第一次更新的状态，所以**是幂等**的。

我对你的建议是，你可以对比一下 SQL 来加深理解：把 **POST 理解成 INSERT，把 PUT 理解成 UPDATE**，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。

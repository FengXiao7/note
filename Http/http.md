# 传送门：

[开篇词｜To Be a HTTP Hero (geekbang.org)](https://time.geekbang.org/column/article/97822)

有机会再来深入体验下抓包流程。

老师讲的极为详细，很多知识作为前端人员没有必要掌握，我会记录下我认为重要的地方



# 破冰期：

## 1.历史

1. HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；
2. HTTP/0.9 是个简单的文本协议，只能获取文本资源；
3. HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；
4. HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；
5. HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；
6. HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。

## 2.HTTP是什么？

先看一下 HTTP 的名字：**“超文本传输协议”**，它可以拆成三个部分，分别是：**“超文本”“传输”和“协议”**。我们从后往前来逐个解析，理解了这三个词，我们也就明白了什么是 HTTP。

![image-20220430175958106](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430175958106.png)

### 协议：

**HTTP 是一个用在计算机世界里的协议。**它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

### 传输：

HTTP 是一个**“传输协议”**，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A<===>B”。

#### HTTP 协议是一个“双向协议”。

也就是说，有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，数据在 A 和 B 之间双向而不是单向流动。通常我们把先发起传输动作的 A 叫做请求方，把后接到传输的 B 叫做应答方或者响应方。

#### 中转

数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。这样，传输方式就从“A<===>B”，变成了“A<=>X<=>Y<=>Z<=>B”，A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议。

**HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。**

### 超文本

所谓“**文本**”（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。

所谓“**超文本**”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。

**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**

### 总结：

**HTTP不是互联网、不是编程语言、不是HTML，不是一个孤立的协议**    

HTTP通常跑在TCP/IP协议栈之上，依靠IP实现寻址和路由、TCP协议实现可靠数据传输、DNS协议实现域名查找、SSL/TLS协议实现安全通信。此外，还有一些协议依赖于HTTP，例如WebSocket、HTTPDNS等。这些协议相互交织，构成了一个协议网，而HTTP则处于中心地位。

## 3.与HTTP相关的概念

### 浏览器

浏览器的正式名字叫“**Web Browser**”，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。

浏览器本质上是一个 HTTP 协议中的**请求方**，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。

在 HTTP 协议里，浏览器的角色被称为“**User Agent”即“用户代理**”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“**客户端**”

### web服务器

刚才说的浏览器是 HTTP 里的请求方，那么在协议另一端的应答方（**响应方**）又是什么呢？这个你一定也很熟悉，答案就是服务器，Web Server。

**硬件含义**就是物理形式或“云”形式的**机器**，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。

**软件含义**的 Web 服务器可能我们更为关心，它就是**提供 Web 服务的应用程序**，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。

### CDN

浏览器和服务器是 HTTP 协议的两个端点，那么，在这两者之间还有别的什么东西吗？当然有了。**浏览器通常不会直接连到服务器**，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。

CDN，全称是“Content Delivery Network”，翻译过来就是“**内容分发网络**”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 有什么好处呢？简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接**在“半路”就可以获取响应**。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。

打个比方，就好像唐僧西天取经，刚出长安城，就看到阿难与迦叶把佛祖的真经递过来了，是不是很省事？

### 爬虫

前面说到过浏览器，它是一种用户代理，代替我们访问互联网。但 HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是**一种可以自动访问 Web 资源的应用程序**。

爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“**反爬虫**”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”**robots.txt**，约定哪些该爬，哪些不该爬。

## 4.与HTTP相关的协议

### TCP/IP

**TCP/IP 协议实际上是一系列网络通信协议的统称**，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。

这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：**TCP 属于“传输层”，IP 属于“网际层”**。

TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议**提供可靠的、字节流形式的通信**，是 HTTP 协议得以实现的基础。

HTTP 是一个"传输协议"，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“**HTTP over TCP/IP**”。

### DNS

“**域名系统**”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代。设想一下，你是愿意记“95.211.80.227”这样枯燥的数字，还是“nginx.org”这样的词组呢？

你想要打电话给小明，但不知道电话号码，就得在手机里的号码簿里一项一项地找，直到找到小明那一条记录，然后才能查到号码。这里的“小明”就相当于域名，而“电话号码”就相当于 IP 地址，这个查找的过程就是**域名解析**。

### URI/URL

URI（Uniform Resource Identifier），中文名称是 **统一资源标识符**，使用它就能够唯一地标记互联网上资源。

URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， **统一资源定位符**，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。

```
http://nginx.org/en/download.html
```

URI 主要有三个基本的部分构成：

- **协议名**：即访问该资源应当使用的协议，在这里是“http”；
- **主机名**：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；
- **路径**：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。

还是用打电话来做比喻，你通过电话簿找到了小明，让他把昨天做好的宣传文案快递过来。那么这个过程中你就完成了一次 URI 资源访问，“小明”就是“主机名”，“昨天做好的宣传文案”就是“路径”，而“快递”，就是你要访问这个资源的“协议名”。

### HTTPS

假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。有没有什么办法能够防止这种情况的发生呢？

确实有。你可以使用“加密”的方法，比如这样打电话：

```
你：“喂，小明啊，接下来我们改用火星文通话吧。”
小明：“好啊好啊，就用火星文吧。”
你：“巴拉巴拉巴拉巴拉……”
小明：“巴拉巴拉巴拉巴拉……”
```

如果你和小明说的火星文只有你们两个才懂，那么即使窃听到了这段谈话，他也不会知道你们到底在说什么，也就无从破坏你们的通话过程。HTTPS 就相当于这个比喻中的“火星文”，它的全称是“**HTTP over SSL/TLS**”，也就是运行在 SSL/TLS 协议上的 HTTP。

注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个**负责加密通信的安全协议**，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。 **HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”**

SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。

### 代理

代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，**既可以转发客户端的请求，也可以转发服务器的应答。**

代理有很多的种类，常见的有：

**匿名代理**：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；

**透明代理**：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；

**正向代理**：靠近客户端，代表客户端向服务器发送请求；

**反向代理**：靠近服务器端，代表服务器响应客户端的请求；



小强给小明打电话要小红的照片——小明是正向代理 

小强要小红的照片小明负责处理——小明是反向代理



由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：

**负载均衡**：把访问请求均匀分散到多台机器，实现访问集群化；

**内容缓存**：暂存上下行的数据，减轻后端的压力；

**安全防护**：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；

**数据处理**：提供压缩、加密等额外的功能。

### 总结：

网络通信是分布式系统的底座，也是信息交互的法宝 

TCP——负责数据传输 

IP——负责标识传输对象 

DNS——负责简化人类的记忆 

URI/L——负责标识传输的资源 

SSL——负责数据传输的安全

 Proxy——负责信息的中转

 像极了走标，

需要搞清楚从哪到哪——IP 

需要搞定怎么传输——TCP 

需要保障货物的安全——SSL 

需要送货的具体位置——URI 

需要把目的地的经纬度换成地址名——DNS 

需要中间中转一下——Proxy 

HTTP——我不那么多，我向你要什么你就给什么

## 5.分层

1、TCP/IP协议是一个“有层次的协议栈” TCP/IP 

2、TCP/IP协议总共有四层，顺序从下往上 链接层->网际层->传输层->应用层 

![image-20220430192930251](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430192930251.png)

3、链接层 link layer ，负责在底层网络上发送原始数据包，使用MAC地址来标记网络上的设备，所以也叫MAC层 

4、网际层 internet layer，IP协议所在层，在链接层的基础上，用IP地址取代MAC地址，把许多局域/广域网连接成虚拟的巨大网络，在这个网络里找设备时只要把IP地址再翻译成MAC地址就可以 

5、传输层 transport layer，TCP、UDP协议所在层，这个层次协议的职责是保证数据在IP地址标记的两点之间可靠地传输。 

6、TCP和UDP区别：    TCP 有状态 需要先建立连接才能发送数据       保证数据不丢失不重复        数据是连续的字节流，有先后顺序    UDP 无状态 不需要先建立连接也可以发送数据    不保证数据一定会发送到对方   数据是分散的小数据包，顺序发、乱序收 

7、应用层 application layer，Telnet、SSH、FTP、SMTP、HTTP  

8、MAC层的传输单位是帧（frame），IP层的传输单位是包（packet），TCP层的传输单位是段（segment），HTTP的传输单位是消息或报文（message）。统称为数据包

 9、OSI网络分层模型    

- 1.第一层:物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等;    
- 2.第二层:数据链路层，它基本相当于TCP/IP的链接层;    
- 3.第三层:网络层，相当于TCP/IP里的网际层;    
- 4.第四层:传输层，相当于TCP/IP里的传输层;   
-  5.第五层:会话层，维护网络中的连接状态，即保持会话和同步;   
-  6.第六层:表示层，把数据转换为合适、可理解的语法和语义;    
-  7.第七层:应用层，面向具体的应用传输数据。 

![image-20220430192957935](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430192957935.png)

10、TCP/IP四层模型和OSI七层网络模型的映射关系    

- 1.第一层:物理层，TCP/IP里无对应;    
- 2.第二层:数据链路层，对应TCP/IP的链接层;    
- 3.第三层:网络层，对应TCP/IP的网际层;    
- 4.第四层:传输层，对应TCP/IP的传输层;    
- 5.第五、六、七层:统一对应到TCP/IP的应用层。 

![image-20220430193016860](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430193016860.png)

11、四层负载均衡：工作在传输层上，基于TCP/IP协议的特性，例如Ip地址，端口号等实现对后端服务器的负载均衡

12、七层负载均衡：工作在应用层上，看到的是HTTP协议，解析HTTP报文里的URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器

**你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。**

假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。

你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。

接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。

之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。

快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。

这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。

![image-20220430193233186](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430193233186.png)

## 6.域名

## 7.搭建HTTP实验环境

# 基础篇

## 08. 键入网址再按下回车，后面究竟发生了什么？

推荐看原文





1.你能试着解释一下在浏览器里点击页面链接后发生了哪些事情吗？ 

浏览器点击页面请求后，正常网络中都是域名，那么浏览器会先用DNS解析一下，拿到服务器的ip和端口，去请求服务器前会先找一下缓存，浏览器自己的缓存-操作系统缓存-本地缓存（Hosts），都没有的话就会到根域名服务器-顶级-权威，当然中间可能有类似CDN这样的代理，那它就可以取CDN中的服务器地址，总的来说，其实就是个“走近道”的过程，就近原则，在DNS不错的情况下，先从离自己近的查起，再一级一级往下。 

2.这一节课里讲的都是正常的请求处理流程，如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？ 

如果是一个不存在的域名，那浏览器还是会从DNS那解析一下，发现，自己，操作系统，本地的缓存都没有，CDN里也没有，根域名，顶级域名，权威域名，非权威域名里 都没有，那它就放弃了，不会建立链接。因为dns解析失败，根本没有进入http处理流程，所以不会有4xx之类的错误，而是dns解析错误信息。



## 09 报文结构

### 报文

HTTP 协议的请求报文和响应报文的结构基本相同，

由三大部分组成：

**起始行**（start line）：描述请求或响应的基本信息；

**头部字段集合**（header）：使用 key-value 形式更详细地说明报文；

**消息正文**（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中**前两部分**起始行和头部字段经常又合称为“**请求头**”或“响应头”，消息正文又称为“**实体**”，但与“header”对应，很多时候就直接称为“**body**”。

HTTP 协议规定报文**必须有 header，但可以没有 body**，而且在 header 之后必须要有一个“**空行**”，也就是“CRLF”，十六进制的“0D0A”。

![image-20220519010309850](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010309850.png)

在很多时候，特别是浏览器发送 GET 请求的时候都是这样，HTTP 报文经常是只有 header 而没 body，相当于只发了一个超级“大头”过来，你可以想象的出来：每时每刻网络上都会有数不清的“大头儿子”在跑来跑去。

### 请求行

**简要地描述了客户端想要如何操作服务器端的资源。**

请求行由三部分构成：

**请求方法**：是一个动词，如 GET/POST，表示对资源的操作；

**请求目标**：通常是一个 URI，标记了请求方法要操作的资源；

**版本号**：表示报文使用的 HTTP 协议版本。这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

![image-20220519010609751](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010609751.png)

例子：**GET  /   HTTP/1.1**

在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”

### 状态行

看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），**意思是服务器响应的状态。**

比起请求行来说，状态行要简单一些，同样也是由三部分构成：

**版本号**：表示报文使用的 HTTP 协议版本；

**状态码**：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；

**原因**：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

![image-20220519010847412](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519010847412.png)

例子：**HTTP/1.1   200   OK**

意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”

### 头部字段

![image-20220519011007519](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519011007519.png)

请求头和响应头的结构是基本一样的，**唯一的区别是起始行**

**头部字段是 key-value 的形式**，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。

比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。

### 常用头字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

**通用字段**：在请求头和响应头里都可以出现；

**请求字段**：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；

**响应字段**：仅能出现在响应头里，补充说明响应报文的信息；

**实体字段**：它实际上属于通用字段，但专门描述 body 的额外信息。

对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，**理解了头字段也就理解了 HTTP 报文。**



**Host 字段，它属于请求字段**，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求**必须出现**的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。

Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择。



**User-Agent 是请求字段**，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。

但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。



**Date 字段是一个通用字段**，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。



**Server 字段是响应字段**，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号。

Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。



**Content-Length是实体字段**，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。

### 小结：

- HTTP 报文结构就像是“大头儿子”，由“**起始行 + 头部 + 空行 + 实体**”组成，简单地说就是“header+body”；
- HTTP 报文可以没有 body，但**必须要有 header**，而且 **header 后也必须要有空行**，形象地说就是“大头”必须要带着“脖子”；
- 请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成；
- 请求行有三部分：请求方法，请求目标和版本号；
- 状态行也有三部分：版本号，状态码和原因字符串；
- 头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；
- HTTP/1.1 里唯一要求**必须提供的头字段是 Host**，它必须出现在请求头里，标记虚拟主机名。

## 10.请求头里的请求方法

需要有某种“动作的指示”，告诉操作资源的方式。所以，就这么出现了“请求方法”。它的实际含义就是**客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。**

目前 HTTP/1.1 规定了八种方法，**单词都必须是大写的形式**。

- GET：获取资源，可以理解为读取或者下载数据；
- HEAD：获取资源的元信息；
- POST：向资源提交数据，相当于写入或上传数据；
- PUT：类似 POST；
- DELETE：删除资源；
- CONNECT：建立特殊的连接隧道；
- OPTIONS：列出可对资源实行的方法；
- TRACE：追踪请求 - 响应的传输路径。

![image-20220519013625067](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519013625067.png)

### GET和HEAD：

**GET的含义是请求从服务器获取资源**，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。

**HEAD 方法与 GET 方法类似**，也是请求从服务器获取资源，服务器的处理机制也是一样的，但**服务器不会返回请求的实体数据，只会传回响应头**，也就是资源的“元信息”。

**HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”**。因为它的**响应头与 GET 完全相同**，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。



### POST和PUT

POST 和 PUT 方法则是相反操作，向 **URI 指定的资源提交数据，数据就放在报文的 body 里**。

POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，**只要向服务器发送数据，用的大多数都是 POST。**

PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 **POST 表示的是“新建”“create”的含义**，而 **PUT 则是“修改”“update”的含义**。在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。

### 其他方法

讲完了 GET/HEAD/POST/PUT，还剩下四个标准请求方法，它们属于比较“冷僻”的方法，应用的不是很多。

**DELETE 方法指示服务器删除资源**，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。

………………

### 扩展方法

虽然 HTTP/1.1 里规定了八种请求方法，但它**并没有限制我们只能用这八种方法**，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。

例如著名的愚人节玩笑 RFC2324，它定义了协议 HTCPCP，即“超文本咖啡壶控制协议”，为 HTTP 协议增加了用来煮咖啡的 BREW 方法，要求添牛奶的 WHEN 方法。(好有意思！)

如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。

### 安全与幂等

在 HTTP 协议里，所谓的“安全”是指**请求方法不会“破坏”服务器上的资源**，即不会对服务器上的资源造成实质的修改。

按照这个定义，只有 **GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作**，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。

而 **POST/PUT/DELETE 操作会修改服务器上的资源**，增加或删除数据，所以是“**不安全**”的。



所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是**多次执行相同的操作，结果也都是相同的**，即多次“幂”后结果“相等”。

很显然，**GET 和 HEAD 既是安全的也是幂等的**，**DELETE** 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。

POST 是“**新增或提交数据**”，多次提交数据会创建多个资源，所以**不是幂等**的；

而 PUT 是“**替换或更新数据**”，多次更新一个资源，资源还是会第一次更新的状态，所以**是幂等**的。

我对你的建议是，你可以对比一下 SQL 来加深理解：把 **POST 理解成 INSERT，把 PUT 理解成 UPDATE**，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。



## 11.你能写出正确的网址吗？

URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。

![image-20220519152220217](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519152220217.png)



- URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；
- URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；
- scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；
- “host:port”表示资源所在的主机名和端口号；
- path 标记资源所在的位置；
- query 表示对资源附加的额外要求；
- 在 URI 里对“@&/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。

## 12 响应状态码

RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。这五类的具体含义是：

- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
- 2××：成功，报文已经收到并被正确处理；
- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
- 4××：客户端错误，请求报文有误，服务器无法处理；
- 5××：服务器错误，服务器在处理请求时内部发生了错误。



### 1××

1××类状态码属于**提示信息**，是**协议处理的中间状态**，实际能够用到的时候很少。

### 2××

2××类状态码表示**服务器收到并成功处理了客户端的请求**，这也是客户端最愿意看到的状态码。

- “**200** OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。
- “**204** No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但**响应头后没有 body 数据**。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。
- “**206** Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 **body 里的数据不是资源的全部，而是其中的一部分**。

### 3xx

3××类状态码表示**客户端请求的资源发生了变动**，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”

“**301** Moved Permanently”俗称“**永久重定向**”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。

“**302** Found”，曾经的描述短语是“Moved Temporarily”，俗称“**临时重定向**”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。301 和 302 都会在响应头里使用字段 **Location** 指明后续要跳转的 URI

“**304** Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“**重定向已到缓存的文件**”（即“缓存重定向”）。

### 4xx

4××类状态码表示**客户端发送的请求报文有误，服务器无法处理**，它就是真正的“错误码”含义了。

“**400** Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它**没有明确说，只是一个笼统的错误**

“**403** Forbidden”实际上不是客户端的请求出错，而是表示**服务器禁止访问资源**。原因可能多种多样，例如信息敏感、法律禁止等

“**404** Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是**资源在本服务器上未找到**，所以无法提供给客户端。

4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：

**405** Method Not Allowed：**不允许使用某些方法操作资源**，例如不允许 POST 只能 GET；

406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；

**408** Request Timeout：**请求超时，服务器等待了过长的时间**；

409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；

413 Request Entity Too Large：请求报文里的 body 太大；

414 Request-URI Too Long：请求行里的 URI 太大；

429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；

431 Request Header Fields Too Large：请求头某个字段或总体太大；



### 5××

5××类状态码表示**客户端请求报文正确**，但**服务器在处理时内部发生了错误**，无法返回应有的响应数据，是服务器端的“错误码”。

“**500** Internal Server Error”与 400 类似，也是一个通用的错误码，**服务器究竟发生了什么错误我们是不知道的**。

“**501** Not Implemented”表示**客户端请求的功能还不支持**，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。

“**502** Bad Gateway”通常是**服务器作为网关或者代理时返回的错误码**，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。

“**503** Service Unavailable”表示**服务器当前很忙，暂时无法响应服务**，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。503 是一个“**临时**”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“**Retry-After**”字段，指示客户端可以在多久以后再次尝试发送请求。

## 13.HTTP特点

推荐看原文

- HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
- HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
- HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
- HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
- HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。

![image-20220519160838632](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519160838632.png)

## 14.HTTP优缺点

推荐看原文

- HTTP **最大的优点是简单、灵活和易于扩展**；
- HTTP 拥有**成熟的软硬件环境**，应用的非常广泛，是互联网的基础设施；
- HTTP 是**无状态**的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
- HTTP 是**明文传输**，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
- HTTP 是**不安全**的，无法验证通信双方的身份，也不能判断报文是否被篡改；
- HTTP 的**性能不算差**，但不完全适应现在的互联网，还有很大的提升空间。

虽然 HTTP 免不了这样那样的缺点，但你也不要怕，别忘了它有一个最重要的“**灵活可扩展**”的优点，所有的缺点都可以在这个基础上想办法解决。

# 进阶篇

## 15.HTTP实体数据

### 数据类型与编码

HTTP用来标记body的数据类型，**MIME type**

MIME 把数据分成了**八大类**，每个大类下再细分出多个子类，形式是“**type/subtype**”的字符串

简单列举一下在 HTTP 里经常遇到的几个类别：

- **text**：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。
- **image**：即图像文件，有 image/gif、image/jpeg、image/png 等。
- **audio/video**：音频和视频数据，例如 audio/mpeg、video/mp4 等。
- **application**：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等



**Encoding type**，告诉数据是用的什么编码格式

比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：

- gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；
- deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；
- br：一种专门为 HTTP 优化的新压缩算法（Brotli）。

### 数据类型使用的头字段

HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“**内容协商**”。

也就是说，**客户端用 Accept 头**告诉服务器希望接收什么样的数据，而**服务器用 Content 头**告诉客户端实际发送了什么样的数据。

#### Accept和Content-Type

**Accept 字段标记的是客户端可理解的 MIME type**，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：

```
Accept: text/html,application/xml,image/webp,image/png
```

这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：

```
Content-Type: text/html
Content-Type: image/png
```

这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。

#### Accept-Encoding 和Content-Encoding

字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段 Content-Encoding 里。

```
Accept-Encoding: gzip, deflate, br
Content-Encoding: gzip
```

**不过这两个字段是可以省略的**，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。

### 语言类型与编码

“语言类型”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用“type-subtype”的形式，不过这里的格式与数据类型不同，**分隔符不是“/”，而是“-”。**

举几个例子：en 表示任意的英语，en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语。



### 语言类型使用的头字段

#### Accept-Language和Content-Language

Accept-Language 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：

```
Accept-Language: zh-CN, zh, en
```

这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。

相应的，服务器应该在响应报文里用头字段 Content-Language 告诉客户端实体数据使用的实际语言类型：

```
Content-Language: zh-CN
```

####  Accept-Charset和Content-Type

字符集在 HTTP 里使用的请求头字段是 Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“**charset=xxx**”来表示，这点需要特别注意。

例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样：

```
Accept-Charset: gbk, utf-8
Content-Type: text/html; charset=utf-8
```

**不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。**

![image-20220519170416645](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519170416645.png)

### 内容协商的质量值

在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。

**权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝**。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，**“;”的意义是小于“,”**的。例如下面的 Accept 字段：

```
Accept: text/html,application/xml;q=0.9,*/*;q=0.8
```

它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。



### 小结：

- 数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；
- 数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；
- 语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；
- 字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；
- 客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；
- Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。

## 16.HTTP传输大文件的方法

### 数据压缩

通常浏览器在发送请求时都会带着“**Accept-Encoding**”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“**Content-Encoding**”响应头里，再把原数据压缩后发给浏览器。

不过这个解决方法也有个缺点，gzip 等压缩算法**通常只对文本文件有较好的压缩率**，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。

### 分块传输

“**化整为零**”的思路在 HTTP 协议里就是“**chunked**”分块传输编码，在响应报文里用头字段“**Transfer-Encoding: chunked**”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 **body 数据的长度是未知**的，无法在头字段“**Content-Length**”里给出确切的长度，所以也只能用 chunked 方式分块发送。

**“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的**，也就是说响应报文里这两个字段**不能同时出现**，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。

***老师也讲了分块的格式，可以看原文***

### 范围请求

比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。

HTTP 协议为了满足这样的需求，提出了“**范围请求**”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。

范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”。

如果不支持的话该怎么办呢？服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。

请求头 **Range** 是 HTTP 范围请求的专用字段，格式是“**bytes=x-y**”，其中的 x 和 y 是以字节为单位的数据范围。

***具体字段看原文吧，很详细***

### 多段数据

刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。

这种情况需要使用一种特殊的 MIME 类型：“**multipart/byteranges**”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记。

![image-20220519175400861](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519175400861.png)

### 小结

- 压缩 HTML 等文本文件是传输大文件最基本的方法；
- 分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；
- 范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；
- 也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。

要注意这四种方法不是互斥的，而是**可以混合起来使用**，例如压缩后再分块传输，或者分段后再分块

## 17.HTTP连接管理

### 短连接：

因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“**短连接**”（short-lived connections）。

短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。

![image-20220519193951214](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519193951214.png)

### 长连接：

针对短连接暴露出的缺点，HTTP 协议就提出了“**长连接**”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。

其实解决办法也很简单，用的就是“**成本均摊**”的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”**均摊**到多个“请求 - 应答”上。



![image-20220519194148857](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519194148857.png)

### 相关头字段

由于长连接对性能的改善效果非常显著，所以在 **HTTP/1.1 中的连接都会默认启用长连接**。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。

当然，我们也可以在请求头里明确地要求使用长连接机制，使用的字段是 **Connection**，值是“**keep-alive**”。

不过不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“**Connection: keep-alive**”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧”。

### 长连接缺点：

因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。

所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。在客户端，可以在请求头里加上“**Connection: close**”字段，告诉服务器：“这次通信后就关闭连接”。

### 队头阻塞

“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。

因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。

![image-20220519195203733](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519195203733.png)

### 性能优化

因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，有什么办法呢？

方案1： **并发连接**。“同时对一个域名发起多个长连接，用数量来解决质量的问题。”HTTP 允许客户端使用并发，但不能滥用。

方案2：“**域名分片**”。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 www.chrono.com。

### 小结

- 早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；
- HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；
- 服务器会发送“Connection: keep-alive”字段表示启用了长连接；
- 报文头里如果有“Connection: close”就意味着长连接即将关闭；
- 过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；
- “队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。

## 18.HTTP的重定向和跳转

我感觉了解即可

### 小结：

- 重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的；
- 301/302 是最常用的重定向状态码，分别是“永久重定向”和“临时重定向”；
- 响应头字段 Location 指示了要跳转的 URI，可以用绝对或相对的形式；
- 重定向可以把一个 URI 指向另一个 URI，也可以把多个 URI 指向同一个 URI，用途很多；
- 使用重定向时需要当心性能损耗，还要避免出现循环跳转。

## 19. HTTP的Cookie机制

怎么样让原本无“记忆能力”的服务器拥有“记忆能力”呢？

既然服务器记不住，那就在外部想办法记住。相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。

### Cookie 的工作过程

Cookie工作流程，需要用到响应头字段：**Set-Cookie**和请求头字段**Cookie** 

1. 客户端第一次请求时，没有cookie信息，服务器会创建一个独特的身份标识数据，格式是“key=value”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。
2. 客户端收到响应后，若Set-Cookie字段不为空，则将Cookie信息存在本地（一般是浏览器中），下一次请求时会将存储的Cookie信息放到头字段Cookie中发送给服务器，多个键值对中间用“;”隔开
3. 服务器再一次收到请求后，通过Cookie字段就能识别出该次请求的身份信息



不过因为服务器的“记忆能力”实在是太差，一张小纸条经常不够用。所以，服务器有时会在响应头里添加**多个 Set-Cookie**，存储多个“key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用“;”隔开就行。

![image-20220519202747477](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519202747477.png)

**Cookie 是由浏览器负责存储的**，而不是操作系统。所以，它是“浏览器绑定”的，**只能在本浏览器内生效**。

如果你换个浏览器或者换台电脑，新的浏览器里没有服务器对应的 Cookie，就好像是脱掉了贴着纸条的衣服，“健忘”的服务器也就认不出来了，只能再走一遍 Set-Cookie 流程。

### Cookie属性

Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息

#### 生存周期：

- “**Expires**”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。
- “**Max-Age**”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。
- Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。

案例：Expires 标记的过期时间是“GMT 2019 年 6 月 7 号 8 点 19 分”，而 Max-Age 则只有 10 秒，如果现在是 6 月 6 号零点，那么 Cookie 的实际有效期就是“6 月 6 号零点过 10 秒”

#### 作用域：

让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。

“**Domain**”和“**Path**”指定了 Cookie 所属的**域名和路径**，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。

#### 安全性：

- 属性“**HttpOnly**”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，“跨站脚本”（XSS）也就无从谈起了。
- 另一个属性“**SameSite**”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。



### Cookie的应用

Cookie 最基本的一个用途就是**身份识别**，保存用户的登录信息，实现会话事务。

Cookie 的另一个常见用途是**广告跟踪**。

### 小结：

- Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”；
- 响应报文使用 Set-Cookie 字段发送“key=value”形式的 Cookie 值；
- 请求报文里用 Cookie 字段发送多个 Cookie 值；
- 为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 等；
- Cookie 最基本的用途是身份识别，实现有状态的会话事务。

![image-20220519205051866](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519205051866.png)

## 20.HTTP的缓存控制

### 服务器的缓存控制

例子：夏天到了，天气很热。你想吃西瓜消暑，于是打开冰箱，但很不巧，冰箱是空的。不过没事，现在物流很发达，给生鲜超市打个电话，不一会儿，就给你送来一个 8 斤的沙瓤大西瓜，上面还贴着标签：“保鲜期 5 天”。好了，你把它放进冰箱，想吃的时候随时拿出来。

在这个场景里，“生鲜超市”就是 Web 服务器，“你”就是浏览器，“冰箱”就是浏览器内部的缓存。整个流程翻译成 HTTP 就是：浏览器发现缓存无数据，于是发送请求，向服务器获取资源；服务器响应请求，返回资源，同时标记资源的有效期；浏览器缓存资源，等待下次重用。

![image-20220519210250761](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519210250761.png)

服务器标记资源有效期使用的头字段是“**Cache-Control**”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”

这里的 max-age 是“**生存时间**”。时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。



- **no-store**：**不允许缓存**，用于某些变化非常频繁的数据，例如秒杀页面；
- 例子：买来的西瓜不允许放进冰箱，要么立刻吃，要么立刻扔掉；
- **no-cache**：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是**可以缓存，但在使用之前必须要去服务器验证是否过期**，是否有最新的版本；
- 例子：可以放进冰箱，但吃之前必须问超市有没有更新鲜的，有就吃超市里的；
- **must-revalidate**：又是一个和 no-cache 相似的词，它的意思是**如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。**
- 例子：可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃。

![image-20220519210636178](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220519210636178.png)

### 客户端的缓存控制

当你点“刷新”按钮的时候，浏览器会在请求头里加一个“**Cache-Control: max-age=0**”。

Ctrl+F5 的“强制刷新”又是什么样的呢？它其实是发了一个“**Cache-Control: no-cache**”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。



### 条件请求

内容很多，推荐看原文。



### 小结：

- 缓存是优化系统性能的重要手段，HTTP 传输的每一个环节中都可以有缓存；
- 服务器使用“Cache-Control”设置缓存策略，常用的是“max-age”，表示资源的有效期；
- 浏览器收到数据就会存入缓存，如果没过期就可以直接使用，过期就要去服务器验证是否仍然可用；
- 验证资源是否失效需要使用“条件请求”，常用的是“if-Modified-Since”和“If-None-Match”，收到 304 就可以复用缓存里的资源；
- 验证资源是否被修改的条件有两个：“Last-modified”和“ETag”，需要服务器预先在响应报文里设置，搭配条件请求使用；
- 浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷新数据。

### Catch和Cookie的异同

Cache 和 Cookie 的相同点是：都会保存到浏览器中，并可以设置过期时间。 

不同点： 

- Cookie 会随请求报文发送到服务器，而 Cache 不会，但可能会携带 if-Modified-Since（保存资源的最后修改时间）和 If-None-Match（保存资源唯一标识） 字段来验证资源是否过期。
- Cookie 在浏览器可以通过脚本获取（如果 cookie 没有设置 HttpOnly），Cache 则无法在浏览器中获取（出于安全原因）。 
- Cookie 通过响应报文的 Set-Cookie 字段获得，Cache缓存的是完整的报文。
-  用途不同。Cookie 常用于身份识别，Cache 则是由浏览器管理，用于节省带宽和加快响应速度。 
- Cookie 的 max-age 是从浏览器拿到响应报文时开始计算的，而 Cache 的 max-age 是从响应报文的生成时间（Date 头字段）开始计算。

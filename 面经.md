

# JS

## 循环

传送门：

https://es6.ruanyifeng.com/#docs/iterator#%E4%B8%8E%E5%85%B6%E4%BB%96%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83

## 数组：

### 1.复制数组

[复制 array/object](https://zh.javascript.info/rest-parameters-spread#fu-zhi-arrayobject)

[如何写出一个惊艳面试官的深拷贝? - 掘金 (juejin.cn)](https://juejin.cn/post/6844903929705136141)

```js
arr.slice()
```

```js
let arrCopy = Object.assign([], arr)
```

```js
let arr = [1, 2, 3];

let arrCopy = [...arr]; // 将数组 spread 到参数列表中// 然后将结果放到一个新数组
```

### 2.数组乱序

[「前端进阶」数组乱序 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903863812620296)

[随机排列数组](https://zh.javascript.info/array-methods#sui-ji-pai-lie-shu-zu)

```js
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
  
  // 所有可能排列的出现次数
  let count = {
    '123': 0,
    '132': 0,
    '213': 0,
    '231': 0,
    '321': 0,
    '312': 0
  };
  
  for (let i = 0; i < 1000000; i++) {
    let array = [1, 2, 3];
    shuffle(array);
    count[array.join('')]++;
  }
  
  // 显示所有可能排列的出现次数
  for (let key in count) {
      console.log(`${key}: ${count[key]}`);
  }
```

### 3.数组去重

[过滤数组中的唯一元素](https://zh.javascript.info/map-set#guo-lv-shu-zu-zhong-de-wei-yi-yuan-su)

```js
Array.from(new Set(arr))
```

[lodash.uniq | Lodash 中文文档 | Lodash 中文网 (lodashjs.com)](https://www.lodashjs.com/docs/lodash.uniq)



### 4.删除数组元素

[比较 javascript 中 filter 和 splice 删除数组的性能 | 木头的博客 (mutoe.com)](https://blog.mutoe.com/2019/compare-filter-vs-splice-in-javascript/)

### 5.创建二维数组

有大坑

[(26条消息) js如何修改二维数组 - CSDN](https://www.csdn.net/tags/NtjaAg2sMzE2MjMtYmxvZwO0O0OO0O0O.html)

```js
const f = new Array(m).fill(0).map(() => new Array(n).fill(0));
```



```js
let dp2 = Array.from({ length: 3 }).map(
  () => Array.from({ length: 5 }).fill(1)
);
```



## 随机数相关

[得到一个两数之间的随机整数，包括两个数在内](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/random#得到一个两数之间的随机整数，包括两个数在内)

```js
function getRandomIntInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值 
}
```

## Map：

### 1.对象和map互转

[Object.entries：从对象创建 Map](https://zh.javascript.info/map-set#objectentries-cong-dui-xiang-chuang-jian-map)

[Object.fromEntries：从 Map 创建对象](https://zh.javascript.info/map-set#objectfromentries-cong-map-chuang-jian-dui-xiang)



## 浏览器的各种宽高

往下翻喔，作者写的很形象

[这些原生DOM操作你还记住多少😨 - 掘金 (juejin.cn)](https://juejin.cn/post/6966062224892756005#heading-24)

加上这篇就够了

[clientX/screenX/offsetX/pageX等属性一览 - 掘金 (juejin.cn)](https://juejin.cn/post/6883353218319908871#comment)

# NodeJS

## 1.util.promisify

用于将老式的`Error first callback`转换为`Promise`对象，让老项目改造变得更为轻松。

传送门：[util.promisify 的那些事儿 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903694807351310)





# 轮子

## 1.PubSubJS 消息订阅与发布

[mroderick/PubSubJS: Dependency free publish/subscribe for JavaScript (github.com)](https://github.com/mroderick/PubSubJS)

消息订阅与发布，组件通信的另一种方式



## 2.synp yarn.lock 和package-lock.json互转

[imsnif/synp: Convert yarn.lock to package-lock.json and vice versa (github.com)](https://github.com/imsnif/synp)

yarn.lock 和package-lock.json互转

## 3.rimraf 卸载node_modules

[rimraf - npm (npmjs.com)](https://www.npmjs.com/package/rimraf)

用于卸载node_modules(全局)：

 rimraf

常用：

在node_modules的上级目录上输入

 rimraf node_modules

即可删除node_modules

参考：

[删除node_modules - 窈窕淑女 - 博客园 (cnblogs.com)](https://www.cnblogs.com/veraNotes/p/12161332.html)

## 4.nrm 切换镜像源

[nrm - npm (npmjs.com)](https://www.npmjs.com/package/nrm)

查看切换镜像源（全局）：

nrm，安装使用失败……

解决办法

[解决：npm中 下载速度慢 和（无法将“nrm”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确， 然后再试一次）。 - 八英里 - 博客园 (cnblogs.com)](https://www.cnblogs.com/deepalley/p/10854204.html)

常用：

nrm ls					显示可选镜像

nrm use 镜像名				切换镜像

## 5.json-server

[typicode/json-server: Get a full fake REST API with zero coding in less than 30 seconds (seriously) (github.com)](https://github.com/typicode/json-server)

用json当数据库，有配套api，一套齐全的简易后台。

## 6.nanoid

有中文！！！

[nanoid/README.zh-CN.md at cb3053e651c5984a8a8f4161c8e4dee424e71d30 · ai/nanoid (github.com)](https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md)

生成全球唯一字符串

```js
import { nanoid } from 'nanoid'
model.id = nanoid() //=> "V1StGXR8_Z5jdHi6B-myT"
```

## 7.serve

//安装
 npm i serve -g

//启动服务
 直接在要项目文件夹目录中，serve 回车

//如果test 文件夹下 有个a文件夹
 cmd的路径是/test 命令：serve a 回车

//react 打包完成后，执行serve -s build，会启动本地服务查看
 //-s可以省略，就是serve服务+文件夹名字

//可能有浏览器缓存，导致页面不对，记住清理缓存.

正式上线，一般都交给后端了。用Ng比较多一点

## 8.eslint-plugin-react-hooks 检查 Hooks 是否正确被使用

官网：

[eslint-plugin-react-hooks - npm (npmjs.com)](https://www.npmjs.com/package/eslint-plugin-react-hooks)

贴心的 React 官方为我们提供了一个 ESLint 的插件，专门用来检查 Hooks 是否正确被使用。

通过这个插件，如果发现缺少依赖项定义这样违反规则的情况，就会报一个错误提示（类似于语法错误的提示），方便进行修改，从而避免 Hooks 的错误使用。

```jsx

npm install eslint-plugin-react-hooks -D
```

然后在你的 ESLint 配置文件中加入两个规则：rules-of-hooks 和 exhaustive-deps。如下：

```json

{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    // 检查 Hooks 的使用规则
    "react-hooks/rules-of-hooks": "error", 
    // 检查依赖项的声明
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

## 9.Immutable和immer 不可变数据

操作不可变数据。我看网上大多推荐学习immer

### 1.Immutable

官网：

[immutable - npm (npmjs.com)](https://www.npmjs.com/package/immutable)

传送门：

[Immutable 详解及 React 中实践 · Issue #3 · camsong/blog (github.com)](https://github.com/camsong/blog/issues/3?fileGuid=tCVw8Y6Cv8J3KYHw)

[15 分钟学会 Immutable - 掘金 (juejin.cn)](https://juejin.cn/post/6976798974757830687)

### 2.Immer

官网：

[immer - npm (npmjs.com)](https://www.npmjs.com/package/immer)

传送门：

[immer.js 使用文档及在Redux项目中的实践 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904024693555213#comment)

## 10.Hooks库

用国内的ahooks吧，文档比较友好。

[ahooks - React Hooks Library - ahooks 3.0](https://ahooks.js.org/zh-CN/)

口碑最好的react-use也可以考虑

[streamich/react-use: React Hooks — 👍 (github.com)](https://github.com/streamich/react-use/)



## 11.表单验证

formik

[Checkboxes Example | Formik 中文文档 (bootcss.com)](https://formik.bootcss.com/examples/checkboxes)

## 12.粒子动画

[tsParticles | JavaScript Particles, Confetti and Fireworks animations for your website](https://particles.js.org/)

[(26条消息) 【前端react 粒子特效】_꧁༺龙小九༻ ꧂的博客-CSDN博客_前端粒子动画](https://blog.csdn.net/weixin_54127208/article/details/124380211?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

## 13.富文本



## 14.阿里云OSS

[ali-sdk/ali-oss: Aliyun OSS(Object Storage Service) JavaScript SDK for the Browser and Node.js (github.com)](https://github.com/ali-sdk/ali-oss)

# 面试

## 常见面试问题：

### 自我介绍：

### 缺点：

**忘性大：**很多学过的知识，在当时学习的那个时间点都能记得很清楚，比如说以前学习的C语言，java，数据库知识，我曾经还用SSM框架搭建了一个图书管理系统，到现在已经完全记不住了。就连最近的学习的，比如CSS的那些属性，webpack的配置文件，正则的写法，原生的js操作，http协议，甚至是vue2都不怎么记得住对应写法，还要去翻阅对应的笔记。**没有什么应用场景，就会忘记对应的知识**

感觉自己学的东西太杂了，没有深入去学习。决定自己方向的时间也很晚，今年年初2,3月份的时候才决定走前端这条路。

**看不进去文档**，遇见问题：百度=》csdn，掘金=》官网文档=》官网github或者stackoverflow

**喜欢看视频学习技术**

**没什么创造力：**往往遇见一个需求，就去找现成的轮子。

**害怕看源码：**从来都不看源码是怎么实现的。

**变量命名往往很难**

### 优点：

学习持之以恒，每天都在进步，有良好的记录习惯。

世俗的来说，就是我学生的这个身份。



传送门：

[做了一份前端面试复习计划，保熟～ - 掘金 (juejin.cn)](https://juejin.cn/post/7061588533214969892#heading-11)

## 架构

### MVC,MVP,MVVM

[MVC，MVP 和 MVVM 的图示 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)

## HTML+CSS

### 1.HTML

#### 1.1语义化

- 让人更容易读懂（增加代码可读性）。
- 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。
- 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。

[不要一直用啦！语义化标签了解下？ - 掘金 (juejin.cn)](https://juejin.cn/post/7021448274431180831#comment)

**不怎么看好，还是喜欢用div+class命名的方式。看评论区知真**

#### 1.2 script 标签中 defer 和 async 的区别？

传送门：

现代JS里面写的极为详细

[脚本：async，defer](https://zh.javascript.info/script-async-defer)

##### script：

现代的网站中，脚本往往比 HTML 更“重”：它们的大小通常更大，处理时间也更长。

当浏览器加载 HTML 时遇到 `<script>...</script>` 标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本 `<script src="..."></script>` 也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。

这会导致两个重要的问题：

1. 脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。
2. 如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容。

我们可以把脚本放在文档底部解决这个问题。但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。

有两个 `<script>` 特性（attribute）可以为我们解决这个问题：`defer` 和 `async`。

##### defer：

`defer` 特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。

这是与上面那个相同的示例，但是带有 `defer` 特性：

```html
<p>...content before script...</p>

<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<!-- 立即可见 -->
<p>...content after script...</p>
```

换句话说：

- 具有 `defer` 特性的脚本不会阻塞页面。
- 具有 `defer` 特性的脚本总是要等到 DOM 解析完毕，但在 `DOMContentLoaded` 事件之前执行。



**具有 `defer` 特性的脚本保持其相对顺序，就像常规脚本一样。**

假设，我们有两个具有 `defer` 特性的脚本：`long.js` 在前，`small.js` 在后。

```html
<script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
<script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
```

浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。因此，在上面的示例中，两个脚本是并行下载的。`small.js` 可能会先下载完成。

……但是，`defer` 特性除了告诉浏览器“不要阻塞页面”之外，还可以确保脚本执行的相对顺序。因此，即使 `small.js` 先加载完成，它也需要等到 `long.js` 执行结束才会被执行。

##### async:

`async` 特性与 `defer` 有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。

`async` 特性意味着脚本是完全独立的：

- 浏览器不会因 `async` 脚本而阻塞（与 `defer` 类似）。
- 其他脚本不会等待 `async` 脚本加载完成，同样，`async` 脚本也不会等待其他脚本。
- DOMContentLoaded和异步脚本不会彼此等待：
  - `DOMContentLoaded` 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）
  - `DOMContentLoaded` 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）

换句话说，`async` 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。`async` 脚本就是一个会在加载完成时执行的完全独立的脚本。就这么简单，现在明白了吧？

下面是一个类似于我们在讲 `defer` 时所看到的例子：`long.js` 和 `small.js` 两个脚本，只是现在 `defer` 变成了 `async`。

它们不会等待对方。先加载完成的（可能是 `small.js`）—— 先执行：

```html
<p>...content before scripts...</p>

<script>
  document.addEventListener('DOMContentLoaded', () => alert("DOM ready!"));
</script>

<script async src="https://javascript.info/article/script-async-defer/long.js"></script>
<script async src="https://javascript.info/article/script-async-defer/small.js"></script>

<p>...content after scripts...</p>
```

- 页面内容立刻显示出来：加载写有 `async` 的脚本不会阻塞页面渲染。
- `DOMContentLoaded` 可能在 `async` 之前或之后触发，不能保证谁先谁后。
- 较小的脚本 `small.js` 排在第二位，但可能会比 `long.js` 这个长脚本先加载完成，所以 `small.js` 会先执行。虽然，可能是 `long.js` 先加载完成，如果它被缓存了的话，那么它就会先执行。换句话说，异步脚本以“加载优先”的顺序执行。

##### 总结：

`async` 和 `defer` 有一个共同点：加载这样的脚本都不会阻塞页面的渲染。因此，用户可以立即阅读并了解页面内容。

但是，它们之间也存在一些本质的区别：

|         | 顺序                                                         | `DOMContentLoaded`                                           |
| :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `async` | **加载优先顺序**。脚本在文档中的顺序不重要 —— 先加载完成的先执行 | 不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自于缓存，同时文档足够长，就会发生这种情况。 |
| `defer` | **文档顺序**（它们在文档中的顺序）                           | 在文档加载和解析完成之后（如果需要，则会等待），即在 `DOMContentLoaded` 之前执行。 |

在实际开发中，`defer` 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候。

`async` 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。

#### 1.3 从浏览器地址栏输入 url 到请求返回发生了什么

传送门：

这个比较简略

[从URL输入到页面展现到底发生什么？ - 掘金 (juejin.cn)](https://juejin.cn/post/6844903784229896199)

这个极为详细

[从输入URL开始建立前端知识体系 - 掘金 (juejin.cn)](https://juejin.cn/post/6935232082482298911#heading-42)

##### 简略过程

- DNS 解析:将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手（HTTP/1.1 中的连接都会默认启用长连接，不会轻易断开连接的。一般使用长连接，除非明确知道只会发送一个请求）

###### 3次握手：

总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。第一次握手可以确认客服端的**发送能力**，第二次握手，确认了服务端的**发送能力和接收能力**，所以第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象。

![image-20220426172143106](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220426172143106.png)

客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口`（第一次握手，由浏览器发起，告诉服务器我要发送请求了）`

服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息`（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）`

客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”`（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）`

###### 浏览器渲染：

1.HTML解析，构建DOM

2.解析CSS，生成CSS规则树

3.合并DOM树和CSS规则，生成render树

4.布局render树（Layout/Reflow），负责各元素尺寸、位置的计算

5.绘制render树（Paint），绘制页面像素信息

###### 4次挥手

![image-20220426172109956](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220426172109956.png)

发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。 `(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)`

被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。 `(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)`

被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。 `(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)`

发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。 `(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)`

为什么需要4次挥手呢？

传送门：

[(98 封私信 / 80 条消息) TCP为什么是四次挥手，而不是三次？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/63264012/answer/1114866844)

tcp是全双工通信，服务端和客服端都能发送和接收数据。

tcp在断开连接时，需要服务端和客服端都确定对方将不再发送数据。

**第1次挥手**

由客户端向服务端发起，服务端收到信息后就能确定客户端已经停止发送数据。

**第2次挥手**

由服务端向客户端发起，客户端收到消息后就能确定服务端已经知道客户端不会再发送数据。

**第3次握手**

由服务端向客户端发起，客户端收到消息后就能确定服务端已经停止发送数据。

**第4次挥手**

由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。

**为什么不是3次挥手**

在客服端第1次挥手时，服务端可能还在发送数据。

所以第2次挥手和第3次挥手不能合并。





### 2.CSS

#### 2.1盒子模型

##### 以前记的笔记：

以前我们，给一个盒子加上border或者padding都会撑大盒子，如果想保证盒子原来的大小。就需要减去多出来的宽度，非常麻烦。CSS3我们可以方便地解决这个问题

![image-20220315153647024](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220315153647024.png)

##### 标准答案：

CSS3 中的盒模型有以下两种：**标准盒模型**、**IE（替代）盒模型**。

两种盒子模型都是由 `content + padding + border + margin` 构成，其大小都是由 `content + padding + border` 决定的，但是盒子内容宽/高度（即 `width/height`）的计算范围根据盒模型的不同会有所不同：

- 标准盒模型：只包含 `content` 。
- IE（替代）盒模型：`content + padding + border` 。

可以通过 `box-sizing` 来改变元素的盒模型：

- `box-sizing: content-box` ：标准盒模型（默认值）。
- `box-sizing: border-box` ：IE（替代）盒模型。

#### 2.2CSS选择器和优先级

##### 选择器：

所有选择器：

[选择器参考表](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FLearn%2FCSS%2FBuilding_blocks%2FSelectors%23%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%82%E8%80%83%E8%A1%A8)

###### 衍生： 结构伪类选择器小坑

![image-20220314193607716](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220314193607716.png)

###### 衍生：链接伪类选择器

```css
/* 1.未访问的链接 a:link  把没有点击过的(访问过的)链接选出来 */
        a:link {
            color: #333;
            text-decoration: none;
        }

        /*2. a:visited 选择点击过的(访问过的)链接 */
        a:visited {
            color: orange;
        }

        /*3. a:hover 选择鼠标经过的那个链接 */
        a:hover {
            color: skyblue;
        }

        /* 4. a:active 选择的是我们鼠标正在按下还没有弹起鼠标的那个链接 */
        a:active {
            color: green;
        }
        /* 
            1.为了确保生效，请按照LVHA的循顺序声明：link-:visited -:hover-:active。
            2.记忆法：love hate 或者 lv 包包hao。  
         */
```

##### 优先级：

传送门：

作者分析的太深入了

[深入理解CSS选择器优先级 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903709772611592)

###### Vscode：

VScode里面把鼠标放在对应选择器上，就会显示对应优先级喔。

遇见复杂的谁还算啊？

![image-20220426174039169](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220426174039169.png)

###### 搬运之前的笔记

\1. 权重是有4组数字组成,但是不会有进位。 
\2. 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推.. 
\3. 等级判断从左向右，如果某一位数值相同，则判断下一位数值。 
\4. 可以简单记忆法:  通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 
1000, !important 无穷大. 
\5. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。

![image-20220307233817276](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220307233817276.png)

![image-20220307234331191](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220307234331191.png)

#### 2.3重绘和回流

传送门;

这个作者写得重绘回流部分比较简略

[从输入URL开始建立前端知识体系 - 掘金 (juejin.cn)](https://juejin.cn/post/6935232082482298911#heading-37)

这个就极为详细

[你真的了解回流和重绘吗](https://juejin.cn/post/6844903779700047885)



##### 重绘（repaint）

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

##### 回流  (reflow)

当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

> 回流必将引起重绘，而重绘不一定会引起回流。

引起回流：

1. 页面首次渲染
2. 浏览器窗口大小发生改变
3. 元素尺寸或位置发生改变
4. 元素内容变化（文字数量或图片大小等等）
5. 元素字体大小变化
6. 添加或者删除可见的DOM元素
7. 激活CSS伪类（例如：:hover）
8. 查询某些属性或调用某些方法

引起回流的属性和方法：

- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- scrollIntoView()、scrollIntoViewIffNeeded()
- getComputedStyle()
- getBoundingClientRect()
- scrollTo()

##### 如何减少回流

- css

1. 避免使用table布局;
2. 尽可能在DOM树的最末端改变class;
3. 避免设置多层内联样式;
4. 将动画效果应用到position属性为absolute或fixed的元素上;
5. 避免使用CSS表达式（例如：calc()）。

- JS

1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
3. 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
4. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
5. 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。



#### 2.4BFC

传送门：

[10 分钟理解 BFC 原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25321647)

视频：

[带你用最简单的方式理解最全面的BFC_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1aZ4y1M7gW?spm_id_from=333.337.search-card.all.click)

怎么说，我以前一直都在使用这个功能，但是不知道这个就是BFC喔。



##### 概念：

 BFC 是什么呢？

BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。

**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通[容器](https://www.zhihu.com/search?q=容器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"25321647"})所没有的一些特性。
**

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

##### 触发：

只要元素满足下面任一条件即可触发 BFC 特性：

- html根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

##### 应用：

###### 1.margin边距塌陷，边距合并问题

之前笔记里写过

###### 2.清除浮动

之前笔记里写过

**3.  BFC 可以阻止元素被浮动元素覆盖**

先来看一个文字环绕效果：

```html
<div style="height: 100px;width: 100px;float: left;background: lightblue">我是一个左浮动的元素</div>
<div style="width: 200px; height: 200px;background: #eee">我是一个没有设置浮动, 
也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</div>
```

![img](https://pic4.zhimg.com/v2-dd3e636d73682140bf4a781bcd6f576b_b.png)

这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 **overflow: hidden**，就会变成：



![img](https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_b.png)

这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。

#### 2.5 实现两栏布局（左侧固定 + 右侧自适应布局）

```jsx
<div class="outer">
  <div class="left">左侧</div>
  <div class="right">右侧</div>
</div>
```

##### 1.浮动

利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 `margin-left` 设为固定宽度 。注意，因为右边元素的 `width` 默认为 `auto` ，所以会自动撑满父元素。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
```

##### 2.浮动+BFC

同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 `overflow: hidden;` 这样右边就触发了 `BFC` ，`BFC` 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  overflow: auto;
  height: 100%;
  background: lightseagreen;
}
```

##### 3.flex

利用 `flex` 布局，左边元素固定宽度，右边的元素设置 `flex: 1` 。

```css
.outer {
  display: flex;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  flex: 1;
  height: 100%;
  background: lightseagreen;
}
```

##### 4.绝对定位

利用绝对定位，父级元素设为相对定位。左边元素 `absolute` 定位，宽度固定。右边元素的 `margin-left` 的值设为左边元素的宽度值。

```css
.outer {
  position: relative;
  height: 100px;
}
.left {
  position: absolute;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
```

##### 5.绝对定位2

利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 `absolute` 定位， `left` 为宽度大小，其余方向定位为 `0` 。

```css
.outer {
  position: relative;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  position: absolute;
  left: 200px;
  top: 0;
  right: 0;
  bottom: 0;
  height: 100%;
  background: lightseagreen;
}
```

#### 2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）

我看大家都说这个现在基本不用……我先放在这里

传送门：

[经典的圣杯布局，和双飞翼布局， 考点是什么 - 掘金 (juejin.cn)](https://juejin.cn/post/7059689846389866504)

圣杯布局和双飞翼布局的目的：

- 三栏布局，中间一栏最先加载和渲染（**内容最重要，这就是为什么还需要了解这种布局的原因**）。
- 两侧内容固定，中间内容随着宽度自适应。
- 一般用于 PC 网页。

#### 2.7 水平垂直居中多种实现方式

##### 1.绝对定位

利用绝对定位，设置 `left: 50%` 和 `top: 50%` 现将子元素左上角移到父元素中心位置，然后再通过 `translate` 来调整子元素的中心点到父元素的中心。该方法可以**不定宽高**。

```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

```

##### 2.绝对定位

利用绝对定位，子元素所有方向都为 `0` ，将 `margin` 设置为 `auto` ，由于宽高固定，对应方向实现平分，该方法必须**盒子有宽高**。

```css
.father {
  position: relative;
}
.son {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0px;
  margin: auto;
  height: 100px;
  width: 100px;
}

```

##### 3.绝对定位

利用绝对定位，设置 `left: 50%` 和 `top: 50%` 现将子元素左上角移到父元素中心位置，然后再通过 `margin-left` 和 `margin-top` 以子元素自己的一半宽高进行负值赋值。该方法**必须定宽高**。

```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 200px;
  height: 200px;
  margin-left: -100px;
  margin-top: -100px;
}

```

##### 4.flex

1. 利用 `flex` ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。

```css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

##### 5.margin(摘自笔记，这个只是水平居中喔)

![image-20220308111844028](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220308111844028.png)

auto:让浏览器自己选择一个合适的外边距。有时，在一些特殊情况下，该值可以使元素居中。

行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可,像下边这样

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>行内元素/行内块元素水平居中对齐</title>
    <style>
      .header {
          width: 900px;
          height: 200px;
          background-color: pink;
          margin: 100px auto;
          text-align: center;
      }
      /* 行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可 */
    </style>
</head>
<body>
    <div class="header">
        <span>里面的文字</span>
    </div>
    <div class="header">
        <img src="down.jpg" alt="">
    </div>
</body>
</html>
```

#### 2.8flex布局

这部分太熟悉了。

#### 2.9 line-height 如何继承？

- 父元素的 `line-height` 写了**具体数值**，比如 `30px`，则子元素 `line-height` 继承该值。
- 父元素的 `line-height` 写了**比例**，比如 `1.5 或 2`，则子元素 `line-height` 也是继承该比例。
- 父元素的 `line-height` 写了**百分比**，比如 `200%`，则子元素 `line-height` 继承的是父元素 `font-size * 200%` 计算出来的值。

建议看笔记。

## JS基础

### 0.this

传送门：

[【建议👍】再来40道this面试题酸爽继续(1.2w字用手整理) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904083707396109)

`this`的5种绑定方式：

- 默认绑定(非严格模式下this指向全局对象, 严格模式下`this`会绑定到`undefined`)
- 隐式绑定(当函数引用有**上下文对象**时, 如 `obj.foo()`的调用方式, `foo`内的`this`指向`obj`)
- 显示绑定(通过`call()`或者`apply()`方法直接指定`this`的绑定对象, 如`foo.call(obj)`)
- new绑定
- 箭头函数绑定(`this`的指向由外层作用域决定的)

#### 1.默认绑定：

##### 1.2

```js
"use strict";
var a = 10;
function foo () {
  console.log('this1', this)
  console.log(window.a)
  console.log(this.a)
}
console.log(window.foo)
console.log('this2', this)
foo();

```

需要注意的点：

- **开启了严格模式，只是说使得函数内的`this`指向`undefined`**，它并不会改变全局中`this`的指向。因此`this1`中打印的是`undefined`，而`this2`还是`window`对象。
- 另外，它也不会阻止`a`被绑定到`window`对象上。

所以最后的执行结果：

```
f foo() {...}
'this2' Window{...}
'this1' undefined
10
Uncaught TypeError: Cannot read property 'a' of undefined
```

##### 1.3

```js
let a = 10
const b = 20

function foo () {
  console.log(this.a)
  console.log(this.b)
}
foo();
console.log(window.a)

```

如果把`var`改成了`let 或者 const`，变量是不会被绑定到`window`上的，所以此时会打印出三个`undefined`。

答案：

```
undefined
undefined
undefined
```

##### 1.5

```js
var a = 1
function foo () {
  var a = 2
  function inner () { 
    console.log(this.a)
  }
  inner()
}

foo()

```

其实这里和`1.4`很像，不过一看到函数内的函数，就很容易让人联想到闭包 😂，然后... 然后就脱口而出，答案是`2`啊，这还不简单。

小伙伴们，审题可得仔细啊，这里问你的是`this.a`，而在`inner`中，`this`指向的还是`window`。

答案：

```
1

```

(我知道有的小伙伴不满这种题目，这吖的不就是和人玩文字游戏吗？有什么技术含量，但是现实就是这样，很多面试官会喜欢问这种细节题来考察你细心不细心。在没能力改变这种情况的前提下，你只能试着接受它...)



#### 2隐式绑定

**this 永远指向最后调用它的那个对象**。

谁最后调用的函数，函数内的`this`指向的就是谁(不考虑箭头函数)。

```js
function foo () {
  console.log(this.a)
}
var obj = { a: 1, foo }
var a = 2
obj.foo()

```

答案

```
1
```

#### 3.隐式绑定的隐式丢失问题

隐式绑定的基本概念大家应该都清楚了，不过其实有一个关于隐式绑定的常用考点，那就是**隐式丢失问题**。

> 隐式丢失其实就是被隐式绑定的函数在特定的情况下会丢失绑定对象。

有两种情况容易发生隐式丢失问题：

- **使用另一个变量来给函数取别名**
- **将函数作为参数传递时会被隐式赋值，回调函数丢失this绑定**

##### 3.1

使用另一个变量来给函数取别名会发生隐式丢失。

```js
function foo () {
  console.log(this.a)
};
var obj = { a: 1, foo };
var a = 2;
var foo2 = obj.foo;

obj.foo();
foo2();

```

执行这段代码会打印出啥呢 🤔️？

在这里我们已经知道了，`obj.foo()`中`this`的指向是为`obj`的(可以看第二部分`隐式绑定`)，所以`obj.foo()`执行的时候，打印出来的是`obj`对象中的`a`，也就是`1`。

但是`foo2`它不也是`obj.foo`吗？我只不过是用了一个变量`foo2`来盛放了它而已。所以你是不是认为它打印的也是`1`呢？

额 😅，其实这里不是的，它打印出的是`window`下的`a`。

答案：

```
1
2
```

这是因为虽然`foo2`指向的是`obj.foo`函数，不过调用它的却是`window`对象，所以它里面`this`的指向是为`window`。

其实也就相当于是`window.foo2()`，如果你不相信的话，可以看下面一题👇。

##### 3.2

让我们在一个新的变量`obj2`中也定义一个`foo2`看看：

```js
function foo () {
  console.log(this.a)
};
var obj = { a: 1, foo };
var a = 2;
var foo2 = obj.foo;
var obj2 = { a: 3, foo2: obj.foo }

obj.foo();
foo2();
obj2.foo2();

```

这三种不同的`foo()`打印出来的分别是什么呢？

答案：

```
1
2
3

```

- `obj.foo()`中的`this`指向调用者`obj`
- `foo2()`发生了隐式丢失，调用者是`window`，使得`foo()`中的`this`指向`window`
- `foo3()`发生了隐式丢失，调用者是`obj2`，使得`foo()`中的`this`指向`obj2`

##### 3.3 对了，但重要

再就是如果你把一个函数当成参数传递时，也会被隐式赋值，发生意想不到的问题。

来看看这道题目：

```js
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this)
  fn()
}
var obj = { a: 1, foo }
var a = 2
doFoo(obj.foo)

```

这里我们将`obj.foo`当成参数传递到`doFoo`函数中，在传递的过程中，`obj.foo()`函数内的`this`发生了改变，指向了`window`。

因此结果为：

```
Window{...}
2
```

注意，我这里说的是`obj.foo()`函数，而不是说`doFoo()`。`doFoo()`函数内的`this`本来就是指向`window`的，因为这里是`window`调用的它。

但是你不要以为是`doFoo()`函数内的`this`影响了`obj.foo()`，不信你看下一题。

##### 3.4 做错了

现在我们不用`window`调用`doFoo`，而是放在对象`obj2`里，用`obj2`调用：

```js
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this)
  fn()
}
var obj = { a: 1, foo }
var a = 2
var obj2 = { a: 3, doFoo }

obj2.doFoo(obj.foo)

```

现在调用`obj2.doFoo()`函数，里面的`this`指向的应该是`obj2`，因为是`obj2`调用的它。

但是`obj.foo()`打印出来的`a`依然是`2`，也就是`window`下的。

执行结果为：

```
{ a:3, doFoo: f }
2

```

**所以说，如果你把一个函数当成参数传递到另一个函数的时候，也会发生隐式丢失的问题，且与包裹着它的函数的this指向无关。在非严格模式下，会把该函数的this绑定到window上，严格模式下绑定到undefined。**

一样的代码，试试严格模式下：

```js
"use strict"
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this)
  fn()
}
var obj = { a: 1, foo }
var a = 2
var obj2 = { a: 3, doFoo }

obj2.doFoo(obj.foo)

```

执行结果：

```
{ a:3, doFoo: f }
Uncaught TypeError: Cannot read property 'a' of undefined
```

#### 4. 显式绑定

功能如其名，就是强行使用某些方法，改变函数内`this`的指向。

通过`call()、apply()`或者`bind()`方法直接指定`this`的绑定对象, 如`foo.call(obj)`。

这里有几个知识点需要注意：

- 使用`.call()`或者`.apply()`的函数是会直接执行的
- `bind()`是创建一个新的函数，需要手动调用才会执行
- `.call()`和`.apply()`用法基本类似，不过`call`接收若干个参数，而`apply`接收的是一个数组

(其实这应该是经常听到的知识点了吧 😅)

##### 4.2 对了，但重要

了解了显式绑定的基本使用之后，让我们来看看它的妙用。

首先，是这个例子🌰：

```js
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    setTimeout(function () {
      console.log(this)
      console.log(this.a)
    }, 0)
  }
}
var a = 3

obj2.foo1()
obj2.foo2()

```

对于`obj2.foo1()`，我们很清楚，它就是打印出`2`。

但是对于`obj2.foo2`呢？在这个函数里，设置了一个定时器，并要求我们打印出`this`和`this.a`。

想想我前面说过的话，谁调用的函数，函数内的`this`指向的就是谁。

而对于`setTimeout`中的函数，这里存在隐式绑定的隐式丢失，也就是当我们将函数作为参数传递时会被隐式赋值，回调函数丢失`this`绑定，因此这时候`setTimeout`中的函数内的`this`是指向`window`的。



所以最终的结果是：

```
2
Window{...}
3
```

##### 4.5

其实在实际面试中，面试官喜欢以这样的方式考你：

看看这道题，会输出什么呢 🤔️？

```js
function foo () {
  console.log(this.a)
}
var obj = { a: 1 }
var a = 2

foo()
foo.call(obj)
foo().call(obj)

```

也就是使用`.call()`方法位置的不同。

结果：

```
2
1
2
Uncaught TypeError: Cannot read property 'call' of undefined

```

- `foo()`会正常打印出`window`下的`a`，也就是`2`
- `foo.call(obj)`由于显式绑定了`this`，所以会打印出`obj`下的`a`，也就是`1`
- `foo().call(obj)`开始会执行`foo()`函数，打印出`2`，但是会对`foo()`函数的返回值执行`.call(obj)`操作，可是我们可以看到`foo()`函数的返回值是`undefined`，因此就会报错了。

所以我们可以看到`foo.call()`和`foo().call()`的区别了，一个是针对于函数，一个是针对于函数的返回值。

##### 4.8 做错了

说实话，做上面这类题目，会让我有一种疑惑。

这种函数内返回的函数，它的`this`会和它外层的函数有关吗？

也就是内层函数它的`this`到底是谁呢？

还是那句话，谁最后调用的它，`this`就指向谁。

```js
function foo () {
  console.log(this.a)
  return function () {
    console.log(this.a)
  }
}
var obj = { a: 1 }
var a = 2

foo.call(obj)()

```

就像是这道题，`foo()`函数内的`this`虽然指定了是为`obj`，但是调用最后调用匿名函数的却是`window`。

所以结果为：

```
1
2

```

（请注意这个例子🌰，后面它会与箭头函数做对比）

##### 4.10 对了，但重要

一直做这种题目是不是没意思，让我们加几个参数来玩玩。

[阴笑]~

```js
var obj = {
  a: 1,
  foo: function (b) {
    b = b || this.a
    return function (c) {
      console.log(this.a + b + c)
    }
  }
}
var a = 2
var obj2 = { a: 3 }

obj.foo(a).call(obj2, 1)
obj.foo.call(obj2)(1)

```

执行结果：

```
6
6

```

- 开始调用`obj.foo(a)`将`2`传入`foo`函数并赋值给型参`b`，并且由于闭包的原因，使得匿名函数内能访问到`b`，之后调用匿名函数的时候，用`call()`改变了`this`的指向，使得匿名函数内`this.a`为`3`，并传入最后一个参数`1`，所以第一行输出的应该是`3 + 2 + 1`，也就是`6`。
- 而第二行，`obj.foo.call(obj2)`这里是将`foo`函数内的`this`指向了`obj2`，同时并没有传递任何参数，所以`b`开始是`undefined`的，但是又因为有一句`b = b || this.a`，使得`b`变为了`3`；同时最后一段代码`(1)`，是在调用匿名函数，且和这个匿名函数内的`this`应该是指向`window`的，因此输出也为`3+2+1`，为`6`。

#### 5. 显式绑定的其它用法

除了上面👆那几道题的用法之外，我们还可以有一些其它的用法。

例如，我们可以在一个函数内使用`call`来显式绑定某个对象，这样无论怎样调用它，其内部的`this`总是指向这个对象。(可见题目`5.1`)

##### 5.1

```js
function foo1 () {
  console.log(this.a)
}
var a = 1
var obj = {
  a: 2
}

var foo2 = function () {
  foo1.call(obj)
}

foo2()
foo2.call(window)

```

这里`foo2`函数内部的函数`foo1`我们使用`call`来显式绑定`obj`，就算后面再用`call`来绑定`window`也没有用了。

结果为：

```
2
2
```

##### 5.3

接下我想要介绍一个比较冷门的知识。

相信大家对`forEach、map、filter`都不陌生吧，它们是`JS`内置的一些函数，但是你知道它们的第二个参数也是能绑定`this`的吗？ 😁

(这个我在现代js里面看过)

传送门:[大多数方法都支持 “thisArg”](https://zh.javascript.info/array-methods#da-duo-shu-fang-fa-du-zhi-chi-thisarg)

来看看下面👇的题目：

```
function foo (item) {
  console.log(item, this.a)
}
var obj = {
  a: 'obj'
}
var a = 'window'
var arr = [1, 2, 3]

// arr.forEach(foo, obj)
// arr.map(foo, obj)
arr.filter(function (i) {
  console.log(i, this.a)
  return i > 2
}, obj)

```

这里的答案为：

```
1 "obj"
2 "obj"
3 "obj"

```

如果我们没有传递第二个参数`obj`的话，`this.a`打印出来的肯定就是`window`下的`a`了，但是传入了之后将`obj`显示绑定到第一个参数函数上。

(关于`arr.filter`为什么也会打印出`1, 2, 3`，那是因为虽然我们使用了`return i > 2`，不过在执行阶段`filter`还是把每一项都打印出来)

##### 总结

总结一下这部分的知识点好了：

- `this` 永远指向最后调用它的那个对象
- 匿名函数的`this`永远指向`window`
- 使用`.call()`或者`.apply()`的函数是会直接执行的
- `bind()`是创建一个新的函数，需要手动调用才会执行
- 如果`call、apply、bind`接收到的第一个参数是空或者`null、undefined`的话，则会忽略这个参数
- `forEach、map、filter`函数的第二个参数也是能显式绑定`this`的



#### 6. new 绑定

好滴，让我们来看看另一种`this`的绑定形式，也就是`new`绑定。

使用`new`来调用一个函数，会构造一个新对象并把这个新对象绑定到调用函数中的`this`。

##### 6.2

构造函数中不仅可以加属性，也可以加方法：

```js
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  }
  this.foo2 = function () {
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo1()
person1.foo2()()

```



```
'person1'
''

```

- 第一个`this.name`打印的肯定是`person1`对象中的`name`，也就是构造`person1`对象时传递进去的`person1`字符串。
- 第二个`this.name`打印的应该就是`window`下的`name`了，但是这里`window`对象中并不存在`name`属性，所以打印出的是空。

在做这道题时，我发现了一个有意思的现象。

我将这道题用浏览器打开，控制台输出的竟然是:

```
'person1'
'window'
```

传送门：

[属性 “name”](https://zh.javascript.info/function-object#shu-xing-name)

##### 6.4

当`new`绑定结合显示绑定，例如`call`函数的话，解起来其实也不难。

来看看下面👇的题目。

```js
var name = 'window'
function Person (name) {
  this.name = name
  this.foo = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo.call(person2)()
person1.foo().call(person2)

```

在做这类题的时候，你就把`Person`生成的`person1`脑补成：

```js
var person1 = {
	name: 'person1',
	foo: function () {
		console.log(this.name)
		return function () {
			console.log(this.name)
		}
	}
}

```

所以答案很容易就出来了：

```
'person2'
'window'
'person1'
'person2'

```

解题分析：

- `person1.foo.call(person2)()`将`foo()`函数内的`this`指向了`person2`，所以打印出`person2`，而内部返回的匿名函数是由`window`调用的，所以打印出`window`。(类似题目`4.9`)
- `person1.foo().call(person2)`是将匿名函数的`this`显式绑定到了`person2`上，所以打印出来的会是`person2`。

#### 7. 箭头函数绑定 都重要

终于到了期待已久的箭头函数绑定 😁。

在上面👆，我们有学到一个诀窍：**this 永远指向最后调用它的那个对象**。

但是对于箭头函数就不是这样咯，**它里面的`this`是由外层作用域来决定的，且指向函数定义时的this而非执行时**。

`它里面的this是由外层作用域来决定的`啥意思呢？来看看这句话：

> 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。

而`且指向函数定义时的this而非执行时`这句话可以等会看题目`7.4`。

读了这句话相信你已经能解决80%的题目了，让我们看完了第一题`7.1`之后，再来看看箭头函数可以分为哪几类题目来说吧，这是目录：

- 字面量对象中普通函数与箭头函数的区别: 只有一层函数的题目
- 字面量对象中普通函数与箭头函数的区别：函数嵌套的题目
- 构造函数对象中普通函数和箭头函数的区别：只有一层函数的题目
- 构造函数对象中普通函数和箭头函数的区别：函数嵌套的题目
- 箭头函数结合`.call`的题目

##### 7.1 

```js
var obj = {
  name: 'obj',
  foo1: () => {
    console.log(this.name)
  },
  foo2: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var name = 'window'
obj.foo1()
obj.foo2()()

```

这道题就非常有代表性，它明确了箭头函数内的`this`是由外层作用域决定的。

- 对于`obj.foo1()`函数的调用，它的外层作用域是`window`，对象`obj`当然不属于作用域了(我们知道作用域只有全局作用域`window`和局部作用域函数)。所以会打印出`window`
- `obj.foo2()()`，首先会执行`obj.foo2()`，这不是个箭头函数，所以它里面的`this`是调用它的`obj`对象，因此打印出`obj`，而返回的匿名函数是一个箭头函数，**它的`this`由外层作用域决定**，那也就是函数`foo2`咯，那也就是它的`this`会和`foo2`函数里的`this`一样，就也打印出了`obj`。

答案：

```
'window'
'obj'
'obj'

```

做完了这道题心里是不是有点谱了，感觉也不是那么难嘛...😁

让我们来拆分一下看看区别。

##### 7.2

**字面量对象中普通函数与箭头函数的区别: 只有一层函数的题目**

```js
var name = 'window'
var obj1 = {
	name: 'obj1',
	foo: function () {
		console.log(this.name)
	}
}

var obj2 = {
	name: 'obj2',
	foo: () => {
		console.log(this.name)
	}
}

obj1.foo()
obj2.foo()

```

解题分析：

- 不使用箭头函数的`obj1.foo()`是由`obj1`调用的，所以`this.name`为`obj1`。
- 使用箭头函数的`obj2.foo()`的外层作用域是`window`，所以`this.name`为`window`。

答案：

```
'obj1'
'window'
```

##### 7.3 错了

我最后一个错了，我写的w,o4.答案是w,w.

**字面量对象中普通函数与箭头函数的区别：函数嵌套的题目**

- `obj1.foo()()`两层都是普通函数，类似于题目`4.6`，分别打印出`obj1`和`window`。
- `obj2.foo()()`外层为普通函数，内层为箭头，类似于题目`7.1`，都是打印出`obj2`。
- `obj3.foo()()`外层为箭头函数，内层为普通函数，箭头函数的`this`由外层作用域决定，因此为`window`，内层普通函数由调用者决定，调用它的是`window`，因此也为`window`。
- `obj4.foo()()`两层都是箭头函数，第一个箭头函数的`this`由外层作用域决定，因此为`window`，第二个箭头函数的`this`也由外层作用域决定，它的外层作用域是第一个箭头函数，而第一个箭头函数的`this`是`window`，因此内层的`this`也是`window`。

答案：

(额，题目太长，为了你好看，所以答案我会把题目复制一遍... 放心... 我这绝对不是为了凑字数...  😅)

```js
var name = 'window'
var obj1 = {
  name: 'obj1',
  foo: function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj2 = {
  name: 'obj2',
  foo: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var obj3 = {
  name: 'obj3',
  foo: () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj4 = {
  name: 'obj4',
  foo: () => {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}

obj1.foo()() // 'obj1' 'window'
obj2.foo()() // 'obj2' 'obj2'
obj3.foo()() // 'window' 'window'
obj4.foo()() // 'window' 'window'
```

##### 7.4 错了

我第二个错了，我写的w。

**构造函数对象中普通函数和箭头函数的区别：一层函数的题目**

```js
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  }
  this.foo2 = () => {
    console.log(this.name)
  }
}
var person2 = {
  name: 'person2',
  foo2: () => {
    console.log(this.name)
  }
}
var person1 = new Person('person1')
person1.foo1()
person1.foo2()
person2.foo2()

```

解题思路：

- `person1.foo1()`是个普通函数，**this由最后调用它的对象决定**，即`person1`。
- `person1.foo2()`为箭头函数，**this由外层作用域决定，且指向函数定义时的this而非执行时**，在这里它的外层作用域是函数`Person`，且这个是构造函数，并且使用了`new`来生成了对象`person1`，所以此时`this`的指向是为`person1`。
- `person2.foo2()`字面量创建的的对象`person2`中的`foo2`是个箭头函数，由于`person2`是直接在`window`下创建的，你可以理解为它所在的作用域就是在`window`下，因此`person2.foo2()`内的`this`应该是`window`。

答案：

```
'person1'
'person1'
'window'
```



##### 7.5

**构造函数对象中普通函数和箭头函数的区别：函数嵌套的题目**

- `person1.foo1()()`两层都是普通函数，这个不再重复说了，打印出`person1`和`window`。(类似题目`6.2`)
- `person1.foo2()()`第一层普通函数，它的`this`是由最后调用它的对象决定也就是`person1`，第二层为箭头函数，它的`this`由外层作用域决定，也就是`foo2`这个函数，因此也为`person1`。
- `person1.foo3()()`第一层为箭头函数，`this`由外层作用域决定，因此为`person1`，第二层为普通函数，由最后调用者决定，因此为`window`。
- `person1.foo4()()`两层都是箭头函数，`this`由外层作用域决定，所以都是`person1`。

答案：

```js
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
  this.foo2 = function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
  this.foo3 = () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
  this.foo4 = () => {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo1()() // 'person1' 'window'
person1.foo2()() // 'person1' 'person1'
person1.foo3()() // 'person1' 'window'
person1.foo4()() // 'person1' 'person1'
```



##### 7.6 错了

错在箭头函数this无法显示修改

**箭头函数结合`.call`的题目**

**箭头函数的`this`无法通过`bind、call、apply`来直接修改，但是可以通过改变作用域中`this`的指向来间接修改。**

```js
var name = 'window'
var obj1 = {
  name: 'obj1',
  foo1: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  },
  foo2: () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj2 = {
  name: 'obj2'
}
obj1.foo1.call(obj2)() // 'obj2' 'obj2'
obj1.foo1().call(obj2) // 'obj1' 'obj1'
obj1.foo2.call(obj2)() // 'window' 'window'
obj1.foo2().call(obj2) // 'window' 'obj2'

```

解题分析：

- `obj1.foo1.call(obj2)()`第一层为普通函数，并且通过`.call`改变了`this`指向为`obj2`，所以会打印出`obj2`，第二层为箭头函数，它的`this`和外层作用域中的`this`相同，因此也是`obj2`。
- `obj1.foo().call(obj2)`第一层打印出`obj1`，第二层为箭头函数，使用了`.call`想要修改`this`的指向，但是并不能成功，因此`.call(obj2)`对箭头函数无效，还是打印出`obj1`。
- `obj1.foo2.call(obj2)()`第一层为箭头函数，并且想要通过`.call(obj2)`改变`this`指向，但是无效，且它的外层作用域是`window`，所以会打印出`window`，第二层为普通函数，`this`是最后调用者`window`，所以也会打印出`window`。
- `obj1.foo2().call(obj2)`第一层为箭头函数，外层作用域是`window`，打印出`window`，第二层为普通函数，且使用了`.call(obj2)`来改变`this`指向，所以打印出了`obj2`。

##### 总结

OK👌，来总结一下箭头函数需要注意的点吧：

- 它里面的`this`是由外层作用域来决定的，且指向函数定义时的`this`而非执行时
- 字面量创建的对象，作用域是`window`，如果里面有箭头函数属性的话，`this`指向的是`window`
- 构造函数创建的对象，作用域是可以理解为是这个构造函数，且这个构造函数的`this`是指向新建的对象的，因此`this`指向这个对象。
- 箭头函数的`this`是无法通过`bind、call、apply`来**直接**修改，但是可以通过改变作用域中`this`的指向来间接修改。

##### **优点**

- 箭头函数写代码拥有更加简洁的语法(当然也有人认为这是缺点)
- `this`由外层作用域决定，所以在某些场合我们不需要写类似`const that = this`这样的代码

#### 8.综合题 都重要

##### 8.1

**字面量对象中的各种场景**

```js
var name = 'window'
var person1 = {
  name: 'person1',
  foo1: function () {
    console.log(this.name)
  },
  foo2: () => console.log(this.name),
  foo3: function () {
    return function () {
      console.log(this.name)
    }
  },
  foo4: function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person2 = { name: 'person2' }

person1.foo1() // 'person1'
person1.foo1.call(person2) // 'person2'

person1.foo2() // 'window'
person1.foo2.call(person2) // 'window'

person1.foo3()() // 'window'
person1.foo3.call(person2)() // 'window'
person1.foo3().call(person2) // 'person2'

person1.foo4()() // 'person1'
person1.foo4.call(person2)() // 'person2'
person1.foo4().call(person2) // 'person1'

```

##### 8.2

**构造函数中的各种场景**

```js
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  },
  this.foo2 = () => console.log(this.name),
  this.foo3 = function () {
    return function () {
      console.log(this.name)
    }
  },
  this.foo4 = function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1() // 'person1'
person1.foo1.call(person2) // 'person2'

person1.foo2() // 'person1'
person1.foo2.call(person2) // 'person1'

person1.foo3()() // 'window'
person1.foo3.call(person2)() // 'window'
person1.foo3().call(person2) // 'person2'

person1.foo4()() // 'person1'
person1.foo4.call(person2)() // 'person2'
person1.foo4().call(person2) // 'person1'

```



##### 8.3 错了

第二部分我写的p1,p2,p1正确答案：o,p2,o

首先是定义了一个构造函数`Person`，不过它与前面几题的区别就是，函数是放在其中的一个叫`obj`的对象里面。

**在这里我提醒一句：this 永远指向最后调用它的那个对象**。

解题分析：

- `person1.obj.foo1()()`返回的是一个普通的匿名函数，调用它的是`window`，所以打印出`window`。
- `person1.obj.foo1.call(person2)()`中是使用`.call(person2)`改变第一层函数中的`this`，匿名函数和它没关系，依旧是`window`调用的，所以打印出`window`。
- `person1.obj.foo1().call(person2)`是通过`.call(person2)`改变匿名函数内的`this`，所以绑定有效，因此打印出`person2`。
- `person1.obj.foo2()()`第一层为普通函数，第二层为匿名箭头函数。首先让我们明确匿名箭头函数内的`this`是由第一层普通函数决定的，所以我们只要知道第一层函数内的`this`是谁就可以了。而这里，第一层函数最后是由谁调用的呢 🤔️？是由`obj`这个对象，所以打印出`obj`。
- `person1.obj.foo2.call(person2)()`中使用`.call(person2)`改变了第一层函数中的`this`指向，所以第二层的箭头函数会打印出`person2`。
- `person1.obj.foo2().call(person2)`中使用`.call(person2)`想要改变内层箭头函数的`this`指向，但是失败了，所以还是为外层作用域里的`this`，打印出`obj`。

答案

```js
var name = 'window'
function Person (name) {
  this.name = name
  this.obj = {
    name: 'obj',
    foo1: function () {
      return function () {
        console.log(this.name)
      }
    },
    foo2: function () {
      return () => {
        console.log(this.name)
      }
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()() // 'window'
person1.obj.foo1.call(person2)() // 'window'
person1.obj.foo1().call(person2) // 'person2'

person1.obj.foo2()() // 'obj'
person1.obj.foo2.call(person2)() // 'person2'
person1.obj.foo2().call(person2) // 'obj'
```



##### 8.4 错了

来看看这里会打印出什么呢？

```js
function foo() {
  console.log( this.a );
}
var a = 2;
(function(){
  "use strict";
  foo();
})();

```

答案并不是`undefined`，也不会报错，而是打印出了`2`。

哈哈😄，其实这里是有一个迷惑点的，那就是`"use strict"`。

我们知道，使用了`"use strict"`开启严格模式会使得`"use strict"`以下代码的`this`为`undefined`，也就是这里的立即执行函数中的`this`是`undefined`。

但是调用`foo()`函数的依然是`window`，所以`foo()`中的`this`依旧是`window`，所以会打印出`2`。

如果你是使用`this.foo()`调用的话，就会报错了，因为现在立即执行函数中的`this`是`undefined`。

或者将`"use strict"`放到`foo()`函数里面，也会报错。

嘻嘻，做做综合题总能使人心情愉悦～

#### 9.手写题 都重要

##### 手写new：

[].shift.call看不懂的可以看这个：

[(26条消息) [\].shift.call( arguments ) 和 [].slice.call( arguments ) 解释_溜_x_i_a_o_迪的博客-CSDN博客_[].shift.call](https://blog.csdn.net/u013946061/article/details/108269650)

```js
function Person(name,age) {
    this.name = name
    this.age = age
}
Person.prototype.eat = function () {
    console.log('Eatting')
}

function create() {
    // 1. 获取构造函数，并且删除 arguments 中的第一项
    var Con = [].shift.call(arguments);

    // 2. 创建一个空的对象并链接到构造函数的原型，使它能访问原型中的属性
    var obj = Object.create(Con.prototype);
    // 3. 使用apply改变构造函数中this的指向实现继承，使obj能访问到构造函数中的属性
    var ret = Con.apply(obj, arguments);
    // 4. 优先返回构造函数返回的对象
    return ret instanceof Object ? ret : obj;
}
var user1 = create(Person, '小冯',21)
console.log(user1)
user1.eat()
```

这里要提一嘴，第四步中为什么要做这么一个判断呢？

**主要是你要考虑构造函数它有没有返回值。**

- 构造函数中有返回值且为对象，那么创建的实例就只能访问到返回对象中的属性，所以要判断一下`ret`的类型，如果是对象的话，则返回这个对象。
- 构造函数中没有返回值，那么创建的实例就能访问到这个构造函数中的所有属性了，此时`ret`就会为`undefined`，所以返回`obj`。
- 构造函数中有返回值但是返回值是`undefined`以外的其它基本类型(比如字符串)，这种情况当成第二种情况(没有返回值)来处理。



我写的：

```js
function Person(name,age) {
    this.name = name
    this.age = age
}
Person.prototype.eat = function () {
    console.log('Eatting')
}


function myNew(){
    //1.
    //args:['小冯',24] constructor:Person
    let args = Array.from(arguments)
    let constructor = args.shift()
    
    //2.
    //obj:以Person.prototype为原型的新对象
    //这样写也行
    // let obj={};
    // Object.setPrototypeOf(obj,constructor.prototype)
    let obj=Object.create(constructor.prototype)
    

    //3.result =Person.apply(Person.prototype,['小冯',24])
    let result = constructor.apply(obj,args)

    // //4.考虑构造函数是否有返回值
    return result instanceof Object ? result : obj
}


var user2 = myNew(Person, '小冯',24)
console.log(user2)
user2.eat()

```

我又写了个：

直接传参数，就明白了咋回事了

```js
function Person(name,age) {
    this.name = name
    this.age = age
}
Person.prototype.eat = function () {
    console.log('Eatting')
}

function myNew(Fun,...args){
    let obj = Object.create(Fun.prototype)
    let result=Fun.apply(obj,args)

    return typeof result === 'object' ? result : obj
}


var user2 = myNew(Person, '小冯',24)
console.log(user2)
user2.eat()

```

##### 手写apply和call：

这个简单，看我的大标题第6点

##### 手写bind:

放弃








### 1.数据类型

#### 1.1 基本的数据类型介绍，及值类型和引用类型的理解

在 JS 中共有 `8` 种基础的数据类型，分别为： `Undefined` 、 `Null` 、 `Boolean` 、 `Number` 、 `String` 、 `Object` 、 `Symbol` 、 `BigInt` 。

其中 `Symbol` 和 `BigInt` 是 ES6 新增的数据类型，可能会被单独问：

- Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。
- BigInt 可以表示任意大小的整数。

写的太简略了，建议看笔记。

#### 1.2 数据类型的判断

##### typeof:

- **typeof**：能判断所有**值类型，函数**。不可对 **null、对象、数组**进行精确判断，因为都返回 `object` 。

```javascript
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```

传送门：

[typeof 运算符](https://zh.javascript.info/types#type-typeof)

##### instanceof:

- **instanceof**：能判断**对象**类型，不能判断基本数据类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。比如考虑以下代码：

```javascript
class People {}
class Student extends People {}

const vortesnail = new Student();

console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true
```

其实现就是顺着**原型链**去找，如果能找到对应的 `Xxxxx.prototype` 即为 `true` 。比如这里的 `vortesnail` 作为实例，顺着原型链能找到 `Student.prototype` 及 `People.prototype` ，所以都为 `true` 。

传送门：

[类检查："instanceof"](https://zh.javascript.info/instanceof)

##### Object.prototype.toString.call()

- **Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等。

```javascript
Object.prototype.toString.call(2); // "[object Number]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(Math); // "[object Math]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"

```

传送门：

[福利：使用 Object.prototype.toString 方法来揭示类型](https://zh.javascript.info/instanceof#fu-li-shi-yong-objectprototypetostring-fang-fa-lai-jie-shi-lei-xing)

在面试中有一个经常被问的问题就是：如何判断变量是否为数组？

```javascript
Array.isArray(arr); // true
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
Object.prototype.toString.call(arr); // "[object Array]"
```



#### 1.3 手写深拷贝

传送门：

[如何写出一个惊艳面试官的深拷贝? - 掘金 (juejin.cn)](https://juejin.cn/post/6844903929705136141)

##### 丐版：

```js
JSON.parse(JSON.stringify());
```

##### 基础版本

- 如果是原始类型，无需继续拷贝，直接返回
- 如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行**深拷贝后**依次添加到新对象上。

```js
function clone(target) {
    if (typeof target === 'object') {
        let cloneTarget = {};
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```

##### 考虑数组：

```js
function clone(target) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```

##### 循环引用：

解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。

这个存储空间，需要可以存储`key-value`形式的数据，且`key`可以是一个引用类型，我们可以选择`Map`这种数据结构：

- 检查`map`中有无克隆过的对象
- 有 - 直接返回
- 没有 - 将当前对象作为`key`，克隆对象作为`value`进行存储
- 继续克隆

```js
function clone(target, map = new Map()) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        if (map.get(target)) {
            return map.get(target);
        }
        map.set(target, cloneTarget);
        for (const key in target) {
            cloneTarget[key] = clone(target[key], map);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```

文章后面部分就不考虑了,不要重复造轮子

工作中一般直接丐版或者lodash库的cloneDeep[Lodash Documentation](https://lodash.com/docs/4.17.15#cloneDeep)



#### 1.4 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？

计组的时候学过IEEE754，因为不考研，已经忘的差不多了……我个人觉得，没有必要了解原理吧，知道存在这种现象

就行了。

传送门：

现代JS里面写的很好。

[不精确的计算](https://zh.javascript.info/number#bu-jing-que-de-ji-suan)

[0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？ - 掘金 (juejin.cn)](https://juejin.cn/post/6844903680362151950#comment)

`进制转换` ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。

`对阶运算` ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（`0舍1入`），尾数位移时可能会发生数丢失的情况，影响精度。

### 2.原型和原型链

作者写的通透，更详细的可以看现代JS。

[JavaScript深入之从原型到原型链 · Issue #2 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/blog/issues/2)

![image-20220427152255333](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220427152255333.png)

```js
function Foo() {}

let f1 = new Foo();
let f2 = new Foo();
```

![image-20220427162012791](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220427162012791.png)

我们先使用构造函数创建一个对象：

```js
function Person() {

}
var person = new Person();
person.name = 'Kevin';
console.log(person.name) // Kevin
```

在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。

很简单吧，接下来进入正题：

#### prototype

每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：

```js
function Person() {

}
// 虽然写在注释里，但是你要注意：
// prototype是函数才会有的属性
Person.prototype.name = 'Kevin';
var person1 = new Person();
var person2 = new Person();
console.log(person1.name) // Kevin
console.log(person2.name) // Kevin
```

那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？

其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的**实例**的原型，也就是这个例子中的 person1 和 person2 的原型。

那什么是原型呢？你可以这样理解：**每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。**

让我们用一张图表示构造函数和实例原型之间的关系：

![image-20220428210510133](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220428210510133.png)

在这张图中我们用 Object.prototype 表示实例原型。

那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：

#### __proto__

这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。

为了证明这一点,我们可以在火狐或者谷歌中输入：

```js
function Person() {

}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true
```

于是我们更新下关系图：

![image-20220428210703641](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220428210703641.png)

既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？

#### constructor

指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。

为了验证这一点，我们可以尝试：

```js
function Person() {

}
console.log(Person === Person.prototype.constructor); // true
```

所以再更新下关系图：

![image-20220428210750879](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220428210750879.png)

综上我们已经得出：

```js
function Person() {

}

var person = new Person();

console.log(person.__proto__ == Person.prototype) // true
console.log(Person.prototype.constructor == Person) // true
// 顺便学习一个ES5的方法,可以获得对象的原型
console.log(Object.getPrototypeOf(person) === Person.prototype) // true
```

了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：

#### 实例与原型

当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。

举个例子：

```js
function Person() {

}

Person.prototype.name = 'Kevin';

var person = new Person();

person.name = 'Daisy';
console.log(person.name) // Daisy

delete person.name;
console.log(person.name) // Kevin
```

在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。

但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。

但是万一还没有找到呢？原型的原型又是什么呢？

#### 原型的原型

在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：

```js
var obj = new Object();
obj.name = 'Kevin'
console.log(obj.name) // Kevin
```

其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图：

![image-20220428211108830](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220428211108830.png)

#### 原型链

那 Object.prototype 的原型呢？

null，我们可以打印：

```js
console.log(Object.prototype.__proto__ === null) // true
```

然而 null 究竟代表了什么呢？

引用阮一峰老师的 [《undefined与null的区别》](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html) 就是：

> null 表示“没有对象”，即该处不应该有值。

所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。

所以查找属性的时候查到 Object.prototype 就可以停止查找了。

最后一张关系图也可以更新为：

![image-20220427152255333](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220427152255333.png)

顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。

#### 补充

最后，补充三点大家可能不会注意的地方：

##### constructor

首先是 constructor 属性，我们看个例子：

```js
function Person() {

}
var person = new Person();
console.log(person.constructor === Person); // true
```

当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：

```js
person.constructor === Person.prototype.constructor
```

##### __proto__

其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。

##### 真的是继承吗？

最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：

继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。

### 3. 作用域与作用域链

简略：

[JavaScript深入之词法作用域和动态作用域 · Issue #3 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/3)

详细：

[深入理解JavaScript作用域和作用域链 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903797135769614)

#### 概念：

##### 形象的说法：

**作用域就是一个独立的地盘，让变量不会外泄、暴露出去**。也就是说**作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。**我感觉有点像BFC喔



##### 严谨的说法：

**作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。**

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

因为 JavaScript 采用的是词法作用域，**函数的作用域在函数定义的时候就决定了。**

而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。





#### 全局作用域：

##### 1.最外层函数 和在最外层函数外面定义的变量拥有全局作用域

```js
var outVariable = "我是最外层变量"; //最外层变量
function outFun() { //最外层函数
    var inVariable = "内层变量";
    function innerFun() { //内层函数
        console.log(inVariable);
    }
    innerFun();
}
console.log(outVariable); //我是最外层变量
outFun(); //内层变量
console.log(inVariable); //inVariable is not defined
innerFun(); //innerFun is not defined

```

##### 2.所有末定义直接赋值的变量自动声明为拥有全局作用域

```js
function outFun2() {
    variable = "未定义直接赋值的变量";
    var inVariable2 = "内层变量2";
}
outFun2();//要先执行这个函数，否则根本不知道里面是啥
console.log(variable); //未定义直接赋值的变量
console.log(inVariable2); //inVariable2 is not defined

```

##### 3.所有window对象的属性拥有全局作用域

##### 弊端：

如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。

```js
// 张三写的代码中
var data = {a: 100}

// 李四写的代码中
var data = {x: true}
```

#### 函数作用域：

是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。

```js
function doSomething(){
    var blogName="浪里行舟";
    function innerSay(){
        alert(blogName);
    }
    innerSay();
}
alert(blogName); //脚本错误
innerSay(); //脚本错误

```

**作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行**。我们看个例子，用泡泡来比喻作用域可能好理解一点：

![image-20220427165257977](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220427165257977.png)

最后输出的结果为 2, 4, 12

- 泡泡1是全局作用域，有标识符foo；
- 泡泡2是作用域foo，有标识符a,bar,b；
- 泡泡3是作用域bar，仅有标识符c。

**块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域**。在块语句中定义的变量将保留在它们已经存在的作用域中。

```js
if (true) {
    // 'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```

这里我推荐看现代JS关于var的部分，很容易理解变量提升

传送门：

[旧时的 "var" (javascript.info)](https://zh.javascript.info/var)

#### 块级作用域：

块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：

1. 在一个函数内部
2. 在一个代码块（由一对花括号包裹）内部

let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：

##### 1.声明变量不会提升到代码块顶部

let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。

```js
function getValue(condition) {
if (condition) {
let value = "blue";
return value;
} else {
// value 在此处不可用
return null;
}
// value 在此处不可用
}

```

##### 2.禁止重复声明

如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。例如：

```js
var count = 30;
let count = 40; // Uncaught SyntaxError: Identifier 'count' has already been declared
```

在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。

```js
var count = 30;
// 不会抛出错误
if (true) {
let count = 40;
// 其他代码
}
```

##### 3.循环中的绑定块作用域的妙用

开发者可能最希望实现for循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如：

```js
for (let i = 0; i < 10; i++) {
  // ...
}
console.log(i);
// ReferenceError: i is not defined
```

上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。

```js
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```

上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。

如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。

```js
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```

上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```js
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc

```

上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。

#### 作用域链：

##### 1.什么是自由变量

首先认识一下什么叫做 **自由变量** 。如下代码中，`console.log(a)`要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。**当前作用域没有定义的变量，这成为 自由变量** 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。

```js
var a = 100
function fn() {
    var b = 200
    console.log(a) // 这里的a在这里就是一个自由变量
    console.log(b)
}
fn()

```

##### 2.什么是作用域链

如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。

```js
var a = 100
function F1() {
    var b = 200
    function F2() {
        var c = 300
        console.log(a) // 自由变量，顺作用域链向父作用域找
        console.log(b) // 自由变量，顺作用域链向父作用域找
        console.log(c) // 本作用域的变量
    }
    F2()
}
F1()
```

##### 3.关于自由变量的取值

关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。

```js
var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  (function() {
    f() //10，而不是20
  })()
}
show(fn)
```

在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，**无论fn函数将在哪里调用**。

所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:**要到创建这个函数的那个域”。 作用域中取值,这里强调的是“创建”，而不是“调用”**，切记切记——其实这就是所谓的"静态作用域"

```js
var a = 10
function fn() {
  var b = 20
  function bar() {
    console.log(a + b) //30
  }
  return bar
}
var x = fn(),
  b = 200
x() //bar()
```

fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了,所以最后的结果是30

### 4.执行上下文

素质4连：

- [JavaScript 深入之执行上下文栈](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4)；
- [JavaScript 深入之变量对象](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F5)；
- [JavaScript 深入之作用域链](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F6)；
- [JavaScript 深入之执行上下文](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F8)。

#### 执行上下文栈：

当执行到一个函数的时候，JavaScript引擎就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做"执行上下文(execution context)"。

接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？

所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文

为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：

```js
ECStack = [];
```

试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：

```js
ECStack = [
    globalContext
];
```

##### 案例1：

现在 JavaScript 遇到下面的这段代码了：

```js
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();
```

**当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。**知道了这样的工作原理，让我们来看看如何处理上面这段代码：

```js
// 伪代码

// fun1()
ECStack.push(<fun1> functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2> functionContext);

// 擦，fun2还调用了fun3！
ECStack.push(<fun3> functionContext);

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

##### 案例2：

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```



```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

两段代码执行的结果一样，(都是local scope)但是两段代码究竟有哪些不同呢？

答案就是执行上下文栈的变化不一样。

让我们模拟第一段代码：

```js
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

让我们模拟第二段代码：

```js
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```

是不是有些不同呢？

#### 变量对象：

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this

讲讲创建变量对象的过程。

##### 函数上下文

在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。

活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

###### 执行过程

执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：

1. 进入执行上下文
2. 代码执行

###### 进入执行上下文

当进入执行上下文时，这时候还没有执行代码，

变量对象会包括：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

举个例子：

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined  //d是变量喔，不是函数声明
}
```

###### 代码执行

在代码执行阶段，**会顺序执行代码，根据代码，修改变量对象的值**

还是上面的例子，当代码执行完后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```

到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：

1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值

##### 思考题

最后让我们看几个例子：

###### 1.第一题

```js
function foo() {
    console.log(a);
    a = 1;
}

foo(); // ???

function bar() {
    a = 1;
    console.log(a);
}
bar(); // ???
```

第一段会报错：`Uncaught ReferenceError: a is not defined`。

第二段会打印：`1`。

这是因为函数中的 "a" 并没有通过 var 关键字声明，所以不会被存放在 AO 中。

第一段执行 console 的时候， AO 的值是：

```
AO = {
    arguments: {
        length: 0
    }
}
```

没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。

当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。

###### 2.第二题

```js
console.log(foo);

function foo(){
    console.log("foo");
}

var foo = 1;
```

会打印函数，而不是 undefined 。

这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

接着进入代码执行阶段，先执行console.log(foo)，此时foo是函数的引用，所以打印函数，再执行var foo = 1。



然而如果把变量声明放在最上面，会打印1.这又是为什么呢？

```js
var foo = 1;
console.log(foo);
function foo(){
    console.log("foo");
};
```

很简单。进入执行上下文阶段和上面的没有差别。而进入代码执行阶段有差别：

这里先执行var foo = 1，再执行console.log(foo),所以打印1。

#### 作用域链：

函数的作用域在函数定义的时候就决定了。

这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！

举个例子：

```js
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为：

```js
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```

##### 函数激活

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。

这时候执行上下文的作用域链，我们命名为 Scope：

```js
Scope = [AO].concat([[Scope]]);
```

至此，作用域链创建完毕。

##### 捋一捋

以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：

```js
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope();
```

执行过程如下：

1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]

```js
checkscope.[[scope]] = [
    globalContext.VO
];
```

2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```js
ECStack = [
    checkscopeContext,
    globalContext
];
```

3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

```
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
```

4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
```

5.第三步：将活动对象压入 checkscope 作用域链顶端

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
```

6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
```

7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出

```js
ECStack = [
    globalContext
];
```

#### this

这里建议看阮老师的文章。

[JavaScript 的 this 原理 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

#### 执行上下文：

当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this

这三个我们都详细讲过了。(this我没看，太复杂了)

在这里分析一下我们在执行上下文中写的实例代码

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

执行过程如下：

1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈

```
    ECStack = [
        globalContext
    ];
```

2.全局上下文初始化

```
    globalContext = {
        VO: [global],
        Scope: [globalContext.VO],
        this: globalContext.VO
    }
```

2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]

```
    checkscope.[[scope]] = [
      globalContext.VO
    ];
```

3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```
    ECStack = [
        checkscopeContext,
        globalContext
    ];
```

4.checkscope 函数执行上下文初始化：

1. 复制函数 [[scope]] 属性创建作用域链，
2. 用 arguments 创建活动对象，
3. 初始化活动对象，即加入形参、函数声明、变量声明，
4. 将活动对象压入 checkscope 作用域链顶端。

同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]

```
    checkscopeContext = {
        AO: {
            arguments: {
                length: 0
            },
            scope: undefined,
            f: reference to function f(){}
        },
        Scope: [AO, globalContext.VO],
        this: undefined
    }
```

5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈

```
    ECStack = [
        fContext,
        checkscopeContext,
        globalContext
    ];
```

6.f 函数执行上下文初始化, 以下跟第 4 步相同：

1. 复制函数 [[scope]] 属性创建作用域链
2. 用 arguments 创建活动对象
3. 初始化活动对象，即加入形参、函数声明、变量声明
4. 将活动对象压入 f 作用域链顶端

```
    fContext = {
        AO: {
            arguments: {
                length: 0
            }
        },
        Scope: [AO, checkscopeContext.AO, globalContext.VO],
        this: undefined
    }
```

7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值

8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

```
    ECStack = [
        checkscopeContext,
        globalContext
    ];
```

9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出

```
    ECStack = [
        globalContext
    ];
```

### 5.闭包

很浅显的解释：[我从来不理解JavaScript闭包，直到有人这样向我解释它 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903858636849159)

阮老师的解释：[学习Javascript闭包（Closure） - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)

#### 解释0：

各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。

由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。

所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

#### 解释1：

闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。

闭包没有那么复杂，本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。

#### 解释2：

在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。

#### 解释3：(MDN)

闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是**函数参数**也不是**函数的局部变量**的**变量**。 闭包 = 函数 + 函数能够访问的自由变量。



#### 实质：

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```

首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。

另一个与这段代码相似的例子，在[《JavaScript深入之执行上下文》](https://github.com/mqyqingfeng/Blog/issues/8)中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。

这里直接给出简要的执行过程：

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2. 全局执行上下文初始化
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
4. checkscope 执行上下文初始化，创建变量对象、作用域链、this等
5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
7. f 执行上下文初始化，创建变量对象、作用域链、this等
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

了解到这个过程，我们应该思考一个问题，那就是：

当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……)

然而 JavaScript 却是可以的！

当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：

```
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。

所以，让我们再看一遍实践角度上闭包的定义：

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2. 在代码中引用了自由变量

**本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。**

#### 必刷题

接下来，看这道刷题必刷，面试必考的闭包题：

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

答案是都是 3，让我们分析一下原因：

当执行到 data[0] 函数之前，此时全局上下文的 VO 为：

```
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```

当执行 data[0] 函数的时候，data[0] 函数的作用域链为：

```
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
```

data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。

data[1] 和 data[2] 是一样的道理。

所以让我们改成闭包看看：

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
        return function(){
            console.log(i);
        }
  })(i);
}

data[0]();
data[1]();
data[2]();
```

当执行到 data[0] 函数之前，此时全局上下文的 VO 为：

```
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```

跟没改之前一模一样。

当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：

```
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO globalContext.VO]
}
```

匿名函数执行上下文的AO为：

```
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}
```

data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。

data[1] 和 data[2] 是一样的道理。

### 6、 call、apply、bind 实现

如果还不清楚这三个的概念，建议看这篇：

[this、apply、call、bind - 掘金 (juejin.cn)](https://juejin.cn/post/6844903496253177863)

#### 概念：

建议看现代JS笔记

#### 自己实现：

传送门：[【建议👍】再来40道this面试题酸爽继续(1.2w字用手整理) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904083707396109#heading-49)

##### call：

> call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

举个例子：

```javascript
var obj = {
  value: "vortesnail",
};

function fn() {
  console.log(this.value);
}

fn.call(obj); // vortesnail
```

通过 `call` 方法我们做到了以下两点：

- `call` 改变了 this 的指向，指向到 `obj` 。
- `fn` 函数执行了。

那么如果我们自己写 `call` 方法的话，可以怎么做呢？我们先考虑改造 `obj` 。

```javascript
var obj = {
  value: "vortesnail",
  fn: function () {
    console.log(this.value);
  },
};

obj.fn(); // vortesnail
```

这时候 this 就指向了 `obj` ，但是这样做我们手动给 `obj` 增加了一个 `fn` 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？

```javascript
obj.fn = fn;
obj.fn();
delete obj.fn;

```

根据这个思路，我们就可以写出来了：

```javascript
Function.prototype.myCall = function (context) {
  // 判断调用对象
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  // 首先获取参数
  let args = [...arguments].slice(1);
  let result = null;
  // 判断 context 是否传入，如果没有传就设置为 window
  context = context || window;
  // 将被调用的方法设置为 context 的属性
  // this 即为我们要调用的方法
  context.fn = this;
  // 执行要被调用的方法
  result = context.fn(...args);
  // 删除手动增加的属性方法
  delete context.fn;
  // 将执行结果返回
  return result;
};
```

我自己写的：

没考虑fn不是函数和context没有传入的情况

```js
Function.prototype.myCall = function (context,...args) {
    //this:fn
    //context:obj
    //...args:1,2
    
    //在obj上添加一个临时函数，这个临时函数和fn是完全一样的
    //执行这个临时函数，保存其运行结果
    //删除临时函数，返回运行结果
    let result = null;

    context.tempFun=this
    result=context.tempFun(...args)
    delete context.tempFun
    return result
};

var obj = {
    value: "vortesnail",
};

function fn(a,b) {
    console.log(this.value);
    console.log(a+b)
}

fn.myCall(obj,1,2); // vortesnail
```

我自己又写了一个：

```js
let obj={
    msg: 'hello'
}
function fn(a,b,c){
    console.log(this.msg)
    console.log(a+b+c)
    return a+b+c;
}

Function.prototype.myCall=function(context){
    if(typeof this !== 'function'){
        throw TypeError('期待函数调用')
    }

    let result=null;
    let tempFun=Symbol('tempFun')
    let args=[...arguments].slice(1)
    
    //这里不能直接写 arguments.slice(1)
    //因为arguments是类数组对象,不能直接用数组原型上的方法
    //所以要先把arguments转换为数组
    //可以这样写Array.from(arguments).slice(1)
    //spread语法也可以。


    context=context||window
    context[tempFun]=this
    result = context[tempFun](...args)
    delete context[tempFun]
    return result;
}

fn.call(obj,1,2,3)
fn.myCall(obj,1,2,3)
```



##### apply：

我们会了 `call` 的实现之后，`apply` 就变得很简单了，他们没有任何区别，除了传参方式。

```javascript
Function.prototype.myApply = function (context) {
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  let result = null;
  context = context || window;
  // 与上面代码相比，我们使用 Symbol 来保证属性唯一
  // 也就是保证不会重写用户自己原来定义在 context 中的同名属性
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  // 执行要被调用的方法
  if (arguments[1]) {
    result = context[fnSymbol](...arguments[1]);
  } else {
    result = context[fnSymbol]();
  }
  delete context[fnSymbol];
  return result;
};
```

我自己写的：

完全没考虑属性覆盖的情况还有空参数的情况……

```js
Function.prototype.myApply = function (context,argsArray) {
    //this:fn
    //context:obj
    //argsArray:[1,2]

    //在obj上添加一个临时函数，这个临时函数和fn是完全一样的
    //执行这个临时函数，保存其运行结果
    //删除临时函数，返回运行结果
    let result = null;

    context.tempFun=this
    result=context.tempFun(...argsArray)
    delete context.tempFun
    return result

    
};

var obj = {
    value: "vortesnail",
};

function fn(a,b) {
    console.log(this.value);
    console.log(a+b)
}

fn.myApply(obj,[1,2]); // vortesnail
```

又写了一个：

```js
let obj = {
    msg: 'hello'
}
function fn(a,b,c) {
    console.log(this.msg)
    console.log(a + b + c)
    return a+b+c;
}

Function.prototype.myApply = function (context,array) {
    if(typeof this !== 'function'){
        throw TypeError('期待函数调用')
    }
    let result = null
    let tempFun = Symbol('tempFun')
    context = context || window

    context[tempFun]=this
    result = array?context[tempFun](...array):context[tempFun]()
    delete context[tempFun]
    return result
}

let sum1= fn.apply(obj, [1,2,3])
let sum2= fn.myApply(obj,[1,2,3])
console.log(sum1,sum2)
```

不传参数数组就用arguments截一下就行



##### bind：

这个手写就很难了。我选择死亡……

详细介绍：

[解析 bind 原理，并手写 bind 实现 · Issue #81 · sisterAn/JavaScript-Algorithms (github.com)](https://github.com/sisterAn/JavaScript-Algorithms/issues/81)



```js
Function.prototype.myBind = function (context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  // 获取参数
  const args = [...arguments].slice(1),
  const fn = this;
  return function Fn() {
    return fn.apply(
      this instanceof Fn ? this : context,
      // 当前的这个 arguments 是指 Fn 的参数
      args.concat(...arguments)
    );
  };
};
```



```js
var obj = {
    value: "vortesnail",
};

function fn(a, b, c) {
    console.log(this.value);
    console.log(a + b +c)
}

fn.myBind(obj, 1, 2, 3)();
fn.myBind(obj, 1, 2)(3);
```



### 7、 new 实现

这个不难

传送门：

[手写源码系列（三）：new操作符的实现 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904005223579655)

[【建议👍】再来40道this面试题酸爽继续(1.2w字用手整理) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904083707396109#heading-49)

1. 首先创一个新的空对象。
2. 根据原型链，设置空对象的 `__proto__` 为构造函数的 `prototype` 。
3. 构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。
4. 判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。

```javascript
function myNew(context) {
  const obj = new Object();
  obj.__proto__ = context.prototype;
  const res = context.apply(obj, [...arguments].slice(1));
  return typeof res === "object" ? res : obj;
}
```

### 8.异步

#### 8.1 event loop、宏任务和微任务

推荐看这篇文章

[做一些动图，学习一下EventLoop - 掘金 (juejin.cn)](https://juejin.cn/post/6969028296893792286#heading-10)

事件循环的具体流程如下：

1. 从宏任务队列中，按照**入队顺序**，找到第一个执行的宏任务，放入调用栈，开始执行；
2. 执行完**该宏任务**下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，**直至微任务队列清空为止**；
3. 当微任务队列清空后，一个事件循环结束；
4. 接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。

这里有几个重点：

- 当我们第一次执行的时候，解释器会将整体代码`script`放入宏任务队列中，因此事件循环是从第一个宏任务开始的；
- 如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。



#### 8.2 Promise

把题做会就行了

[【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904077537574919#heading-10)

`Promise.resolve().then`是微任务

##### 我的错题：

###### 2.5

```js
const promise1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("success");
        console.log("timer1");
    }, 1000);
    console.log("promise1里的内容");
});
const promise2 = promise1.then(() => {
    throw new Error("error!!!");
});
console.log("promise1", promise1);
console.log("promise2", promise2);
setTimeout(() => {
    console.log("timer2");
    console.log("promise1", promise1);
    console.log("promise2", promise2);
}, 2000);
```

![image-20220429145520097](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220429145520097.png)

###### 3.2 catch后面的then

```js
const promise = new Promise((resolve, reject) => {
    reject("error");
    resolve("success2");
});
promise
    .then(res => {
        console.log("then1: ", res);
    }).then(res => {
        console.log("then2: ", res);
    }).catch(err => {
        console.log("catch: ", err);
    }).then(res => {
        console.log("then3: ", res);
    })
```

我只写了catch,没写then3

![image-20220429150009013](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220429150009013.png)

至于`then3`也会被执行，那是因为`catch()`也会返回一个`Promise`，且由于这个`Promise`没有返回值，所以打印出来的是`undefined`。

###### 3.6 return一个error

```js
Promise.resolve().then(() => {
    return new Error('error!!!')
}).then(res => {
    console.log("then: ", res)
}).catch(err => {
    console.log("catch: ", err)
})

```

t它是return一个error喔，不是throw一个error。

所以是then: Error:error!!!,不是catch: Error:error!!!

返回任意一个非 `promise` 的值都会被包裹成 `promise` 对象，因此这里的`return new Error('error!!!')`也被包裹成了`return Promise.resolve(new Error('error!!!'))`。

当然如果你抛出一个错误的话，可以用下面👇两的任意一种：

```js
return Promise.reject(new Error('error!!!'));
// or
throw new Error('error!!!')
```

###### 3.7 返回本身

```js
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)
```

`.then` 或 `.catch` 返回的值不能是 promise 本身，否则会造成死循环。

所以报错

###### 3.8 值传透

```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)

```

`.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传。

第一个`then`和第二个`then`中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将`resolve(1)` 的值直接传到最后一个`then`里。

所以输出结果为：

```
1
```

###### 3.10 finally

和finally相关

建议看原文。

传送门：[【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904077537574919#heading-26)

```js
function promise1 () {
  let p = new Promise((resolve) => {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) => {
    reject('error')
  })
}
promise1()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .finally(() => console.log('finally1'))

promise2()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .finally(() => console.log('finally2'))
```

执行过程：

- 首先定义了两个函数`promise1`和`promise2`，先不管接着往下看。
- `promise1`函数先被调用了，然后执行里面`new Promise`的同步代码打印出`promise1`
- 之后遇到了`resolve(1)`，将`p`的状态改为了`resolved`并将结果保存下来。
- 此时`promise1`内的函数内容已经执行完了，跳出该函数
- 碰到了`promise1().then()`，由于`promise1`的状态已经发生了改变且为`resolved`因此将`promise1().then()`这条微任务加入本轮的微任务列表(**这是第一个微任务**)
- 这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将`.finally`加入微任务列表，那是因为`.then`本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管`.finally()`
- 再往下走碰到了`promise2()`函数，其中返回的`new Promise`中并没有同步代码需要执行，所以执行`reject('error')`的时候将`promise2`函数中的`Promise`的状态变为了`rejected`
- 跳出`promise2`函数，遇到了`promise2().catch()`，将其加入当前的微任务队列(**这是第二个微任务**)，且链式调用后面的内容得等该任务执行完后才执行，和`.then()`一样。
- OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在`promise1().then()`，执行它，打印出`1`，然后遇到了`.finally()`这个微任务将它加入微任务列表(**这是第三个微任务**)等待执行
- 再执行`promise2().catch()`打印出`error`，执行完后将`finally2`加入微任务加入微任务列表(**这是第四个微任务**)
- OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行`finally1`和`finally2`。

结果：

```
'promise1'
'1'
'error'
'finally1'
'finally2'

```

在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为**链式调用**后面的内容需要等前一个调用执行完才会执行。

就像是这里的`finally()`会等`promise1().then()`执行完才会将`finally()`加入微任务队列，其实如果这道题中你把`finally()`换成是`then()`也是这样的:

```js
function promise1 () {
  let p = new Promise((resolve) => {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) => {
    reject('error')
  })
}
promise1()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .then(() => console.log('finally1'))

promise2()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .then(() => console.log('finally2'))
```

###### 5.2 awiat+定时器

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  setTimeout(() => {
    console.log('timer')
  }, 0)
  console.log("async2");
}
async1();
console.log("start")
```

没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。

答案：

```
'async1 start'
'async2'
'start'
'async1 end'
'timer'
```



###### 5.9 多个awiat

```js
async function testSometing() {
  console.log("执行testSometing");
  return "testSometing";
}

async function testAsync() {
  console.log("执行testAsync");
  return Promise.resolve("hello async");
}

async function test() {
  console.log("test start...");
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();

var promise = new Promise(resolve => {
  console.log("promise start...");
  resolve("promise");
});
promise.then(val => console.log(val));

console.log("test end...");

```



```
'test start...'
'执行testSometing'
'promise start...'
'test end...'
'testSometing'
'执行testAsync'
'promise'
'hello async'
'testSometing' 'hello async'
```

我的答案promise在最后执行。

也就是说await testAsync()，这里await的时候，是先执行的外面的微任务。

###### 7.2综合题

```js
const async1 = async () => {
  console.log('async1');
  setTimeout(() => {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 end')
  return 'async1 success'
} 
console.log('script start');
async1().then(res => console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res => console.log(res))
setTimeout(() => {
  console.log('timer2')
}, 1000)
```

注意的知识点：

- `async`函数中`await`的`new Promise`要是没有返回值的话则不执行后面的内容(类似题`5.5`)
- `.then`函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题`3.8` )
- 注意定时器的延迟时间

我踩中了第一个坑

因此本题答案为：

```
'script start'
'async1'
'promise1'
'script end'
1
'timer2'
'timer1'
```

###### 7.3综合题 finally返回值

```js
const p1 = new Promise((resolve) => {
  setTimeout(() => {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  resolve('resovle1');
  resolve('resolve2');
}).then(res => {
  console.log(res)
  setTimeout(() => {
    console.log(p1)
  }, 1000)
}).finally(res => {
  console.log('finally', res)
})

```

注意的知识点：

- `Promise`的状态一旦改变就无法改变(类似题目`3.5`)
- `finally`不管`Promise`的状态是`resolved`还是`rejected`都会执行，且它的回调函数是接收不到`Promise`的结果的，所以`finally()`中的`res`是一个迷惑项(类似`3.10`)。
- 最后一个定时器打印出的`p1`其实是`.finally`的返回值，我们知道`.finally`的返回值如果在没有抛出错误的情况下默认会是上一个`Promise`的返回值(`3.10`中也有提到), 而这道题中`.finally`上一个`Promise`是`.then()`，但是这个`.then()`并没有返回值，所以`p1`打印出来的`Promise`的值会是`undefined`，如果你在定时器的**下面**加上一个`return 1`，则值就会变成`1`

答案：

```
'resolve1'
'finally' undefined
'timer1'
Promise{<resolved>: undefined}
```



##### 做对了但是值得看一看：

###### 1.4，2.4，3.3，3.5



###### 3.9 then的第2个参数

第一个参数是用来处理`Promise`成功的函数，第二个则是处理失败的函数。

也就是说`Promise.resolve('1')`的值会进入成功的函数，`Promise.reject('2')`的值会进入失败的函数。

让我们来看看这个例子🌰：

```js
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })

```

这里的执行结果是：

```
'error' 'error!!!'

```

它进入的是`then()`中的第二个参数里面，而如果把第二个参数去掉，就进入了`catch()`中：

```js
Promise.reject('error!!!')
  .then((res) => {
    console.log('success', res)
  }).catch(err => {
    console.log('catch', err)
  })

```

执行结果：

```
'catch' 'error!!!'
```

###### 4.1 all正常运行

```js
function runAsync(x) {
    const p = new Promise(resolve=>{
        setTimeout(function(){
            console.log(x)
            resolve(x)
        },1000)
    })
    return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log(res))

```

先来想想此段代码在浏览器中会如何执行？

没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出`1, 2, 3`，还有一个数组`[1, 2, 3]`。

```
1
2
3
[1, 2, 3]
```

所以你现在能理解这句话的意思了吗：**有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。**

`.all()`后面的`.then()`里的回调函数接收的就是所有异步操作的结果。

而且这个结果中数组的顺序和`Promise.all()`接收到的数组顺序一致！！！

###### 4.2 all捕获错误

我新增了一个`runReject`函数，它用来在`1000 * x`秒后`reject`一个错误。

同时`.catch()`函数能够捕获到`.all()`里最先的那个异常，并且只执行一次。

想想这道题会怎样执行呢 🤔️？

```js
function runAsync(x) {
    const p = new Promise(r =>
        setTimeout(() => {
            console.log(x)
            r(x)
        }, 1000)
    )
    return p
}
function runReject(x) {
    const p = new Promise((res, rej) =>
        setTimeout(() => {
            console.log(x)
            rej(`Error: ${x}`)
        }, 1000 * x))
    return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
    .then(res => console.log(res))
    .catch(err => console.log(err))
//
```

不卖关子了 😁，让我来公布答案：

```
// 1s后输出
1
3
// 2s后输出
2
Error: 2
// 4s后输出
4

```

没错，就像我之前说的，**`.catch`是会捕获最先的那个异常**，在这道题目中最先的异常就是`runReject(2)`的结果。

另外，如果一组异步操作中有一个异常都不会进入`.then()`的第一个回调函数参数中。

###### 4.3 race

`.race()`方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过`race`已经不管那些任务的结果了。

来，改造一下`4.1`这道题：

```js
function runAsync(x) {
    const p = new Promise(r =>
        setTimeout(() => {
            console.log(x)
            r(x)
        }, 1000)
    )
    return p
}
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log('result: ', res))
  .catch(err => console.log(err))
```

执行结果为：

```
1
'result: ' 1
2
3
```



```js
function runAsync(x) {
    const p = new Promise(r =>
        setTimeout(() => {
            console.log(x)
            r(x)
        }, 1000)
    )
    return p
}
function runReject(x) {
    const p = new Promise((res, rej) =>
        setTimeout(() => {
            console.log(x)
            rej(`Error: ${x}`)
        }, 1000 * x))
    return p
}
Promise.race([runAsync(1), runReject(3), runReject(0), runAsync(2),])
    .then(res => console.log("result: ", res))
    .catch(err => console.log(err));

```

捕获最先执行的runReject(0)，其他函数虽然都执行了，但是不管执行结果。

<img src="https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/143.gif" style="zoom: 100%"></img>

###### all和trace总结：

`Promise.all()`的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。

`.race()`的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。

`Promise.all().then()`结果中数组的顺序和`Promise.all()`接收到的数组顺序一致。

`all和race`传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被`then`的第二个参数或者后面的`catch`捕获；但并不会影响数组中其它的异步任务的执行。

###### 5.3  定时器延迟一样，就看宏队列

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  setTimeout(() => {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() => {
    console.log('timer2')
  }, 0)
  console.log("async2");
}
async1();
setTimeout(() => {
  console.log('timer3')
}, 0)
console.log("start")


```

思考一下🤔，执行结果会是什么？
其实如果你能做到这里了，说明你前面的那些知识点也都掌握了，我就不需要太过详细的步骤分析了。
直接公布答案吧：

```
'async1 start'
'async2'
'start'
'async1 end'
'timer2'
'timer3'
'timer1'
```

代码定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是0，所以只要关注谁先被调用的。

**时间一样看宏任务队列，时间不一样按时间执行**

###### 5.5 await一个pending的promise

我就是把await后面的也写了……

```js
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')
```

这道题目比较有意思，大家要注意了。

在`async1`中`await`后面的`Promise`是没有返回值的，也就是它的状态始终是`pending`状态，因此相当于一直在`await`，`await`，`await`却始终没有响应...



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb1987d7181b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



所以在`await`之后的内容是不会执行的，也包括`async1`后面的 `.then`。

答案为：

```
'script start'
'async1 start'
'promise1'
'script end'
```

###### 5.6 await一个fulfilled的promise

让我们给`5.5`中的`Promise`加上`resolve`：

```js
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
    resolve('promise1 resolve')
  }).then(res => console.log(res))
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')
```

现在`Promise`有了返回值了，因此`await`后面的内容将会被执行：

```
'script start'
'async1 start'
'promise1'
'script end'
'promise1 resolve'
'async1 success'
'async1 end'
```

###### 5.8头条面试题

不过如此嘛~

我们再来看一道头条曾经的面试题：

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

async function async2() {
  console.log("async2");
}

console.log("script start");

setTimeout(function() {
  console.log("setTimeout");
}, 0);

async1();

new Promise(function(resolve) {
  console.log("promise1");
  resolve();
}).then(function() {
  console.log("promise2");
});
console.log('script end')
```

###### 6.1 await一个rejected的promise

在`async`中，如果 `await`后面的内容是一个异常或者错误的话，会怎样呢？

```js
async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}
async function async2 () {
  return new Promise((resolve, reject) => {
    console.log('async2')
    reject('error')
  })
}
async1().then(res => console.log(res))
```

例如这道题中，`await`后面跟着的是一个状态为`rejected`的`promise`。

**如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。**

所以答案为：

```
'async2'
Uncaught (in promise) error
```

如果改为`throw new Error`也是一样的：

```js
async function async1 () {
  console.log('async1');
  throw new Error('error!!!')
  return 'async1 success'
}
async1().then(res => console.log(res))

```

结果为：

```
'async1'
Uncaught (in promise) Error: error!!!
```

###### 6.2 await+try-catch

如果想要使得错误的地方不影响`async`函数后续的执行的话，可以使用`try catch`

```js
async function async1 () {
  try {
    await Promise.reject('error!!!')
  } catch(e) {
    console.log(e)
  }
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')
```

这里的结果为：

```js
'script start'
'error!!!'
'async1'
'async1 success'
```

或者你可以直接在`Promise.reject`后面跟着一个`catch()`方法：

```js
async function async1 () {
  // try {
  //   await Promise.reject('error!!!')
  // } catch(e) {
  //   console.log(e)
  // }
  await Promise.reject('error!!!')
    .catch(e => console.log(e))
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')
```

###### 7.1综合题

```js
const first = () => (new Promise((resolve, reject) => {
    console.log(3);
    let p = new Promise((resolve, reject) => {
        console.log(7);
        setTimeout(() => {
            console.log(5);
            resolve(6);
            console.log(p)
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) => {
        console.log(arg);
    });
}));
first().then((arg) => {
    console.log(arg);
});
console.log(4);
```

过程分析：

- 第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在`4`之前，所以可以来看看`first`函数里面的内容了。(这一步有点类似于题目`1.5`)
- 函数`first`返回的是一个`new Promise()`，因此先执行里面的同步代码`3`
- 接着又遇到了一个`new Promise()`，直接执行里面的同步代码`7`
- 执行完`7`之后，在`p`中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走
- 碰到了`resolve(1)`，这里就把`p`的状态改为了`resolved`，且返回值为`1`，不过这里也先不执行
- 跳出`p`，碰到了`resolve(2)`，这里的`resolve(2)`，表示的是把`first`函数返回的那个`Promise`的状态改了，也先不管它。
- 然后碰到了`p.then`，将它加入本次循环的微任务列表，等待执行
- 跳出`first`函数，遇到了`first().then()`，将它加入本次循环的微任务列表(`p.then`的后面执行)
- 然后执行同步代码`4`
- 本轮的同步代码全部执行完毕，查找微任务列表，发现`p.then`和`first().then()`，依次执行，打印出`1和2`
- 本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码`5`
- 然后又遇到了一个`resolve(6)`，它是放在`p`里的，但是`p`的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说`resolve(6)`相当于没任何用处，因此打印出来的`p`为`Promise{<resolved>: 1}`。(这一步类似于题目`3.1`)

结果：

```
3
7
4
1
2
5
Promise{<resolved>: 1}
```

##### 大厂面试题：

###### 8.1 使用Promise实现每隔1秒输出1,2,3

这道题比较简单的一种做法是可以用`Promise`配合着`reduce`不停的在`promise`后面叠加`.then`

```js
const arr = [1, 2, 3]

arr.reduce((total,item)=>{
    return total.then(()=>{
        return new Promise(resolve=>{
            setTimeout(()=>{
                console.log(item),
                resolve()
            },1000)
        })
    })
},Promise.resolve())
//上面代码相当于这样：
Promise.resolve()
    .then(()=>{
        return new Promise(resolve=>{
            setTimeout(()=>{
                console.log(1),
                resolve()
            },1000)
        })
    })
    .then(()=>{
        return new Promise(resolve=>{
            setTimeout(()=>{
                console.log(2),
                resolve()
            },1000)
        })
    })
    .then(()=>{
        return new Promise(resolve=>{
            setTimeout(()=>{
                console.log(3),
                resolve()
            },1000)
        })
    })

```

###### 8.2 使用Promise实现红绿灯交替重复亮

红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：

```
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
```

我说实话，没看清题意：

我以为题意是叫我们实现这个：

```js
setInterval(red,3000)
setInterval(yellow,2000)
setInterval(green,1000)
```

结果不是啊

```js
function red() {
  console.log("red");
}
function green() {
  console.log("green");
}
function yellow() {
  console.log("yellow");
}
const light = function (timer, cb) {
  return new Promise(resolve => {
    setTimeout(() => {
      cb()
      resolve()
    }, timer)
  })
}
const step = function () {
  Promise.resolve().then(() => {
    return light(3000, red)
  }).then(() => {
    return light(2000, green)
  }).then(() => {
    return light(1000, yellow)
  }).then(() => {
    return step()
  })
}

step();
```

###### 8.3自己实现Promise.all

传送门：[因为实现不了Promise.all，一场面试凉凉了 - 掘金 (juejin.cn)](https://juejin.cn/post/7038371452084551694#heading-8)

```js
//promises是一个数组，里面装的每一项都应该是一个promise
Promise.myAll = (promises) => {
    return new Promise((rs, rj) => {
      // 计数器
      let count = 0
      // 存放结果
      let result = []
      const len = promises.length
      
      if (len === 0) {
        return rs([])
      }
      
      promises.forEach((p, i) => {
        // 注意有的数组项有可能不是Promise，需要手动转化一下
        Promise.resolve(p).then((res) => {
          count += 1
          // 收集每个Promise的返回值 
          result[ i ] = res
          // 当所有的Promise都成功了，那么将返回的Promise结果设置为result
          if (count === len) {
            rs(result)
          }
          // 监听数组项中的Promise catch只要有一个失败，那么我们自己返回的Promise也会失败
        }).catch(rj)
      })
    })
  }
```



### 9、 浏览器的垃圾回收机制

传送门：

现代JS

[垃圾回收 (javascript.info)](https://zh.javascript.info/garbage-collection#nei-bu-suan-fa)

![image-20220429210213503](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220429210213503.png)

传送门：

[「硬核JS」你真的了解垃圾回收机制吗 - 掘金 (juejin.cn)](https://juejin.cn/post/6981588276356317214#heading-0)



### 10、 实现一个 EventMitter 类

没听说过，这是啥呀？

### 11.封装 class

传送门：

[🔥【何不三连】比继承家业还要简单的JS继承题-封装篇(牛刀小试) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904094948130824#heading-21)

#### 1.ES6之前的封装

（虽然以下内容是概念部分，但是对你解题很有帮助哦，请务必仔细阅读它 😁）

都知道`ES6`的`class`实际就是一个语法糖，那么在`ES6`之前，是没有类这个概念的，因此是借助于**原型对象**和**构造函数**来实现。

- 私有属性和方法：只能在构造函数内访问不能被外部所访问(在构造函数内使用`var`声明的属性)(**用let也行**)
- 公有属性和方法(或实例方法)：对象外可以访问到对象内的属性和方法(**在构造函数内使用`this`设置，或者设置在构造函数原型对象上**比如`Cat.prototype.xxx`)
- 静态属性和方法：**定义在构造函数上的方法(**比如`Cat.xxx`)，不需要实例就可以调用(例如`Object.assign()`)

##### 1.1**私有属性方法**和公有属性方法

(理解**私有属性方法**和**公有属性方法**)

比如我现在想要封装一个生产出猫，名为`Cat`的构造函数。

- 由于猫的`心`和`胃`都是我们肉眼看不见的，所以我把它们设置为私有属性(隐藏起来)
- 并且猫的`心跳`我们也是看不到的，所以我把它设置为私有方法(隐藏起来)
- 然后猫的`毛色`是可以看见的，所以我把它设置为公有属性
- 并且猫`跳起来`这个动作我们是看的到的，所以我把它设置为公有方法

```js
function Cat (name, color) {
  var heart = '❤️'
  var stomach = '胃'
  var heartbeat = function () {
    console.log(heart + '跳')
  }

  this.name = name
  this.color = color

  this.jump = function () {
    heartbeat() // 能跳起来表明这只猫是活的,心也就能跳
    console.log('我跳起来了~来追我啊')
  }
}
var guaiguai = new Cat('guaiguai', 'white')
console.log(guaiguai)
guaiguai.jump()
```

上述代码打印出来的应该是：

```
Cat{ name: 'guaiguai', color: 'white', jump: function(){} }
❤️跳
我跳起来了~来追我啊

```

可以看到，我们生产出名字叫做`乖乖`的小猫咪只有这几个属性能访问到(也就是能被肉眼看到)，为公有属性：

- `name`
- `color`
- `jump`

而私有属性，是我们看不到的：

- `heart`
- `somach`
- `heartbeat`

所以如果你想要直接使用它是不能够的：

```
// 私有
console.log(guaiguai.heart) // undefined
console.log(guaiguai.stomach) // undefined
guaiguai.heartbeat() // 报错
```

很好区分：

- 在函数内用`var`定义的就是私有的
- 在函数内用`this`承接的就是公有

##### 1.2 静态属性方法和公有属性方法

(理解**静态属性方法**和**公有属性方法**)

我们现在往刚刚的`Cat`构造函数中加些东西。

- 我们需要对`Cat`这个构造函数加一个描述，表明它是用来生产猫的，所以我把`descript`设置为它的静态属性
- 由于一听到猫这种动物就觉得它会卖萌，所以我把`卖萌`这个动作设置为它的静态方法
- 由于猫都会用唾液清洁身体，所以我把`清洁身体`这个动作设置为它的公有方法

```js
// 这段是旧代码
function Cat (name, color) {
  var heart = '❤️'
  var stomach = '胃'
  var heartbeat = function () {
    console.log(heart + '跳')
  }

  this.name = name
  this.color = color

  this.jump = function () {
    heartbeat() // 能跳起来表明这只猫是活的,心也就能跳
    console.log('我跳起来了~来追我啊')
  }
}
// 这段是新增的代码
Cat.descript = '我这个构造函数是用来生产出一只猫的'
Cat.actingCute = function () {
  console.log('一听到猫我就想到了它会卖萌')
}
Cat.prototype.cleanTheBody = function () {
  console.log('我会用唾液清洁身体')
}
var guaiguai = new Cat('guaiguai', 'white')

console.log(Cat.descript)
Cat.actingCute()
console.log(guaiguai.descript)
guaiguai.cleanTheBody()
```

上述代码打印出来的应该是：

```
'我这个构造函数是用来生产出一只猫的'
'一听到猫我就想到了它会卖萌'
undefined
'我会用唾液清洁身体'
```

可以看到，我们定义的`descript`和`actingCute`是定义在构造函数`Cat`上的，所以可以直接被`Cat`调用，为静态属性和方法。

但是`descript`和`actingCute`并不能存在于`乖乖`这个实例上，`descript`只是对构造函数`Cat`的描述，并不是对`乖乖`的描述，所以打印出`undefined`。

不过`清洁`身体是定义在原型对象`prototype`中的，属于公有方法(实例方法)，也就是`乖乖`这个实例可以用它来调用。

静态属性和方法：

- `descript`
- `actingCute`

实例(公有)属性和方法：

- `name`
- `color`
- `jump`
- `cleanTheBody`

**小结：**

也很好区分：

- 在构造函数上也就是使用`Cat.xxx`定义的是静态属性和方法
- 在构造函数内使用`this`设置，或者设置在构造函数原型对象上比如`Cat.prototype.xxx`，就是公有属性和方法(实例方法)

（也有小伙伴可能会有疑问，这个`静态属性和方法`是有什么用的啊，感觉我们编码的时候并没有用到过啊。`Really?` 哈哈 😄，`Promise.all()、Promise.race()、Object.assign()、Array.from()`这些不就是吗？）

（至于`实例方法`，想想`push、shift`，它们实际上不是存在于原型对象上的吗？`Array.prototype.push`）

##### 1.3 自身属性和原型对象上的属性

（理解**实例自身的属性**和**定义在构造函数原型对象中的属性**的区别）

```js
function Cat (name) {
  this.name = name
}
Cat.prototype.prototypeProp = '我是构造函数原型对象上的属性'
Cat.prototype.cleanTheBody = function () {
  console.log('我会用唾液清洁身体')
}
var guaiguai = new Cat('guaiguai')
console.log(guaiguai)
console.log(guaiguai.name)
console.log(guaiguai.prototypeProp)
guaiguai.cleanTheBody()
```

这里输出的结果 🤔️？

```
Cat {name: "guaiguai"}
'guaiguai'
'我是构造函数原型对象上的属性'
'我会用唾液清洁身体'

```

看到没，`name`是使用`this.xxx = xxx`的形式定义的，它能直接让实例`guaiguai`就拥有这个属性。

而`prototypeProp 、cleanTheBody`毕竟是定义在构造函数原型上的，所以并不能出现在实例`guaiguai`上，但是`guaiguai`却能访问和调用它们。

因此我们得出结论：

**定义在构造函数原型对象上的属性和方法虽然不能直接表现在实例对象上，但是实例对象却可以访问或者调用它们**

##### 1.4 区分自身属性和原型对象上的属性

既然我们已经知道了**实例自身的属性**和**定义在构造函数原型对象中的属性**的区别，那么我们一般是如何区分它们的呢？

来看看这里：

```js
function Cat (name) {
  this.name = name
}
Cat.prototype.prototypeProp = '我是构造函数原型对象上的属性'
Cat.prototype.cleanTheBody = function () {
  console.log('我会用唾液清洁身体')
}
var guaiguai = new Cat('guaiguai')

for (key in guaiguai) {
  if (guaiguai.hasOwnProperty(key)) {
    console.log('我是自身属性', key)
  } else {
    console.log('我不是自身属性', key)
  }
}
console.log('-分隔符-')
console.log(Object.keys(guaiguai))
console.log(Object.getOwnPropertyNames(guaiguai))

```

这道题中，我分别用了三种方式来获取实例对象`guaiguai`上的属性名：

- `for...in...`
- `Object.keys()`
- `Object.getOwnPropertyNames()`

输出的结果为：

```
'我是自身属性 name'
'我不是自身属性 prototypeProp'
'我不是自身属性 cleanTheBody'
'-分隔符-'
["name"]
["name"]

```

由此可以得出：

- 使用`for...in...`能获取到实例对象自身的属性和原型链上的属性
- 使用`Object.keys()`和`Object.getOwnPropertyNames()`只能获取实例对象自身的属性
- 可以通过`.hasOwnProperty()`方法传入属性名来判断一个属性是不是实例自身的属性

（上面👆的说法其实并不太严谨，因为要建立在可枚举属性的前提下(属性的`enumerable`为`true`)，不过这边我不发散下去了...）

##### 1.5 错了

我把那几个报错的写成undefined了

```js
function Person (name, sex) {
  this.name = name
  this.sex = sex
  var evil = '我很邪恶'
  var pickNose = function () {
    console.log('我会扣鼻子但不让你看见')
  }
  this.drawing = function (type) {
    console.log('我要画一幅' + type)
  }
}
Person.fight = function () {
  console.log('打架')
}
Person.prototype.wc = function () {
  console.log('我是个人我会wc')
}
var p1 = new Person('lindaidai', 'boy')
console.log(p1.name)
console.log(p1.evil)
p1.drawing('国画')
p1.pickNose()
p1.fight()
p1.wc()
Person.fight()
Person.wc()
console.log(Person.sex)
```

答案：

```
'lindaidai'
undefined
'我要画一幅国画'
Uncaught TypeError: p1.pickNose is not a function
Uncaught TypeError: p1.fight is not a function
'我是个人我会wc'
'打架'
Uncaught TypeError: Person.wc is not a function
undefined
```

解析：

- `name`为公有属性，实例访问它打印出`'lindaidai'`
- `evil`为私有属性，实例访问它打印出`'undefined'`
- `drawing`是共有(实例)方法，实例调用它打印出`'我要画一幅国画'`
- `pickNose`是私有方法，实例调用它会报错，因为它并不存在于实例上
- `fight`是静态方法，实例调用它报错，因为它并不存在于实例上
- `wc`存在于构造函数的原型对象中，使用实例调用它打印出`'我是个我会wc'`
- `fight`存在于构造函数上，使用构造函数调用它打印出`'打架'`
- `wc`存在于构造函数的原型对象中，并不存在于构造函数中，所以报错
- `sex`为公有(实例)属性，并不存在于构造函数上，使用构造函数访问它为`undefined`

这里大家可能会有一个疑惑点了，为什么最后一个`Person.sex`也会是`undefined`呢？

我明明已经这样写了：

```js
function Person (sex) {
	this.sex = sex
}
```

看起来`sex`是定义在`Person`里的呀。

注意了，`this.sex`表示的是给使用构造函数创建的实例上增加属性`sex`，而不是给构造函数本身增加(只有`Person.sex`才是给构造函数上增加属性)。

##### 1.7

现在我在`Cat`的原型对象上，还有它原型对象的原型对象上都定义一个叫做`color`的属性。

(原型对象本质也是个对象，所以它的`__proto__`也就是`Object.prototype`)

```js
function Cat () {
  this.color = 'white'
  this.getColor = function () {
    console.log(this.color)
  }
}
Cat.prototype.color = 'black'
Object.prototype.color = 'yellow'
Object.prototype.feature = 'cute'
var cat = new Cat()

cat.getColor()
console.log(cat)
console.log(cat.feature)
```

然后让我们来看看结果：

```
'white'
Cat {color: "white", getColor: ƒ}
'cute'
```

看到了不。

`color`这个属性还是以它自身的`white`为主，但是`feature`这个属性没在实例`cat`上吧，所以它就会向上一层一层查找，结果在`Object.prototype`中找到了，因此打印出`cute`。

![image-20220430215754985](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430215754985.png)

#### 2. ES6之后的封装  务必重点看看看

在`ES6`之后，新增了`class` 这个关键字。

它可以用来代替构造函数，达到创建“一类实例”的效果。

并且类的数据类型就是**函数**，所以用法上和构造函数很像，直接用`new`命令来配合它创建一个实例。

还有一件事你可能不知道吧，那就是，**类的所有方法都定义在类的prototype属性上面**。

```js
class Cat {
    constructor() {

    }
    toString() {

    }
    toValue() {

    }
}
// 等同于
function Cat() {

}
Cat.prototype = {
    constructor() {

    },    
    toString() {

    },   
    toValue() {

    }
}


```

##### 2.1

现在我们将`1.1`的题目换成`class`版本的来看看。

```js
class Cat {
  constructor (name, color) {
    var heart = '❤️'
    var stomach = '胃'
    var heartbeat = function () {
      console.log(heart + '跳')
    }

    this.name = name
    this.color = color
    this.jump = function () {
      heartbeat()
     	console.log('我跳起来了~来追我啊')
    }
  }
}
var guaiguai = new Cat('guaiguai', 'white')
console.log(guaiguai)
guaiguai.jump()

```

其实你会发现，当你使用`class`的时候，它会默认调用`constructor`这个函数，来接收一些参数，并构造出一个新的实例对象(`this`)并将它返回，因此它被称为`constructor`构造方法(函数)。

(另外，其实如果你的`class`没有定义`constructor`，也会隐式生成一个`constructor`方法)

可以看到，经过用`class`改造后的`Cat`

公有(实例)属性和方法：

- `name`
- `color`
- `jump`

而对于私有属性，个人感觉上述的`heart`不应该叫做私有属性，它只不过被局限于`constructor`这个构造函数中，是这个作用域下的变量而已。

执行结果：

```
Cat{ name: 'guaiguai', color: 'white', jump: function () {} }
❤️跳
'我跳起来了~来追我啊'
```



##### 2.2 做错了 重点看看

（弄懂在类中定义属性或方法的几种方式）

```js
class Cat {
  constructor () {
    var heart = '❤️'
    this.name = 'guaiguai'
    this.jump = function () {}
  }
  color = 'white'
  cleanTheBody = function () {
    console.log('我会用唾液清洁身体')
  }
  hideTheShit () {
    console.log('我在臭臭完之后会把它藏起来')
  }
}
var guaiguai = new Cat()
console.log(guaiguai)
console.log(Object.keys(guaiguai))
guaiguai.cleanTheBody()
guaiguai.hideTheShit()
```

请仔细看看这道题，在这里面我用了四种不同的方式来定义一些属性。

1. 在`constructor`中`var`一个变量，它只存在于`constructor`这个构造函数中
2. 在`constructor`中使用`this`定义的属性和方法会被定义到实例上
3. **在`class`中使用`=`来定义一个属性和方法，效果与第二点相同，会被定义到实例上**
4. 在`class`中直接定义一个方法，会被添加到`原型对象prototype`上

至此，这道题的答案为：

```
Cat {color: "white", name: "guaiguai", cleanTheBody: ƒ, jump: ƒ}
["color", "cleanTheBody", "name", "jump"]
'我会用唾液清洁身体'
'我在臭臭完之后会把它藏起来'
```

解析：

- `heart`只能在`constructor`函数中使用，因此不会出现在实例上。
- `name、jump、color、cleanTheBody`满足于上面👆说到的第二点和第三点
- `hideTheShit`是在类里直接定义的，满足于上面👆说的第四点，因此它不会被`Object.keys()`获取到。
- `hideTheShit`虽然是在原型对象中，但是也还是能被实例对象所调用，因此最后一段代码也会被执行`'我在臭臭完之后会把它藏起来'`



这四种定义的方式已经介绍完了 😁，相信大家比较迷惑的一点就是以下这两种方式的定义吧：

```
class Cat {
    cleanTheBody = function () {}
    hideTheShit () {}
}

```

看起来都是定义一个函数呀，为什么第一个就可以在实例对象中，而第二个是在原型对象中呢 🤔️ ？

其实不需要特意的去记住它，你只需要知道：**在类的所有方法都定义在类的prototype属性上面**。

这里的`cleanTheBody`你可以理解为它和`color`一样只是一个普通的变量，只不过这个变量是个函数，所以它并不算是定义在类上的函数，因此不会存在于原型对象上。

而`hideTheShit`是实实在在的定义在类上的方法，所以它和`constructor`方法一样，都是在类的原型对象上。

转化为伪代码就是：

```js
class Cat {
    constructor() {}
    hideTheShit () {}
}
// 等同于
function Cat () {}
Cat.prototype = {
    constructor() {}
    hideTheShit () {}
}
```



##### 2.3 做错了

我忘记执行heartbeat函数了……

(在`class`定义静态属性和方法)

前面我们给`Cat`定义静态属性和方法是采用这种方式，`Cat.xxx`：

```js
function Cat () {...}
Cat.descript = '我这个构造函数是用来生产出一只猫的'
Cat.actingCute = function () {
  console.log('一听到猫我就想到了它会卖萌')
}

```

在`class`中你也可以使用`Cat.xxx`这种方式定义，因为前面说过了，`class`本质也是个对象。

但除此之外，你还可以使用`static`标识符表示它是一个静态的属性或者方法：

```js
class Cat {
  static descript = '我这个类是用来生产出一只猫的'
  static actingCute () {
    console.log('一听到猫我就想到了它会卖萌')
  }
	// static actingCute = function () {} // 这种写法也是设置静态的方法
}

```

OK👌，现在让我们来做做下面这道题吧 😊：

```js
class Cat {
  constructor (name, color) {
    var heart = '❤️'
    var stomach = '胃'
    var heartbeat = function () {
      console.log(heart + '跳')
    }
    this.name = name
    this.color = color
    heartbeat()
    this.jump = function () {
      console.log(this)
      console.log('我跳起来了~来追我啊')
    }
  }
  cleanTheBody = function () {
    console.log('我会用唾液清洁身体')
  }
  static descript = '我这个类是用来生产出一只猫的'
  static actingCute () {
    console.log(this)
    console.log('一听到猫我就想到了它会卖萌')
  }
}
Cat.staticName = 'staticName'//这个就相当于在Cat类里面写 static staticName = 'staticName'
var guaiguai = new Cat('guaiguai', 'white')

console.log(guaiguai)
guaiguai.jump()
guaiguai.cleanTheBody()
console.log(guaiguai.descript)
guaiguai.actingCute()

Cat.actingCute()
console.log(Cat.descript)
console.log(Cat.staticName)
```

结果：

```
❤️跳
Cat{ name: 'guaiguai', color: 'white', jump: function(){}, cleanTheBody: function(){} }
Cat{ name: 'guaiguai', color: 'white', jump: function(){}, cleanTheBody: function(){} }
'我跳起来了~来追我啊'
'我会用唾液清洁身体'
undefined
Uncaught TypeError: guaiguai.actingCute is not a function

class Cat{...}
'一听到猫我就想到了它会卖萌'
'我这个类是用来生产出一只猫的'
'staticName'

```

结果分析：

- 首先在构造`guaiguai`这个对象的时候会执行`heartbeat`方法，打印出`❤️跳`
- 其次打印出的`guaiguai`它只会拥有`class`中定义的实例属性和方法，所以并不会有`descript`和`actingCute`
- `jump`中的`this`指向的是实例对象`guaiguai`，并且执行了`'我跳起来了~来追我啊'`
- 直接定义在`class`中的属性或者方法就相当于是定义在`实例对象`上，所以也属于实例方法，`cleanThebody`会执行打印出`'我会用唾液清洁身体'`
- 使用了`static`定义的属性和方法为静态属性和方法，并不存在于实例上，所以打印出`undefined`和报错
- `actingCute`使用了`static`修饰符，所以它是静态方法，存在于`Cat`这个类上，因此它里面的`this`指向这个类，并且执行了`'一听到猫我就想到了它会卖萌'`
- `descript`使用了`static`修饰符，所以它是静态属性，打印出`'我这个类是用来生产出一只猫的'`
- `Cat.staticName = 'staticName'`就相当于定义了一个静态属性，所以打印出`staticName`

##### 2.4 坑1

我们再来看看这道题，友情提示，这是个坑 🤮...

```js
var a = new A()
function A () {}
console.log(a)

var b = new B()
class B {}
console.log(b)

```

你开始的预想是不是：

```
A{}
B{}

```

😁，结果却发现报错了：

```
A {}
Uncaught ReferenceError: Cannot access 'B' before initialization

```

那是因为，函数`A`是会被提升至作用域的最顶层，所以可以在定义函数`A`之前使用`new A()`

**但是类却不存在这种提升机制**，所以当你执行`new B()`的时候它就会告诉你在`B`没有初始化之前不能使用它。

尽管我们知道，`class`它的本质也是一个函数：

```
console.log(typeof B) // function
```

##### 2.5 坑2 做错了

```js
class Cat {
  constructor () {
    this.name = 'guaiguai'
    var type = 'constructor'
  }
  type = 'class'
  getType = function () {
    console.log(this.type)
    console.log(type)
  }
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.getType()

```

这里的执行结果是什么呢？

主要是考察了你对作用域以及`class`的理解。

答案为：

```
'class'
'window'

```

解析：

- 调用`getType`函数的是`guaiguai`，所以里面的`this`指向了`guaiguai`，而`guaiguai`上的`type`为`class`
- 当要打印出`type`的时候，发现`getType`函数中并没有这个变量，所以就向外层查找，找到了`window`中存在这个变量，因此打印出`window`。(`var type = 'constructor'`是函数`constructor`中的变量, 你也可以理解为是`constructor`函数的私有变量)

##### 2.5扩展

```js
class Cat {
    constructor() {
        this.name = 'guaiguai'
        this.type = 'constructor'
    }
    type = 'class'
    getType = function () {
        console.log(this.type)
        console.log(type)
    }
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.getType()
```

答案：

![image-20220502153326610](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220502153326610.png)

1. 在`constructor`中使用`this`定义的属性和方法会被定义到实例上
2. 在`class`中使用`=`来定义一个属性和方法，效果与第1点相同，会被定义到实例上

两个如果同名，以constructor中的为准

##### 2.6 箭头函数

```js
class Cat {
  constructor () {
    this.name = 'guaiguai'
    var type = 'constructor'
  }
  type = 'class'
  getType = () => {
    console.log(this.type)
    console.log(type)
  }
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.getType()
console.log(guaiguai)

```

现在调用`guaiguai.getType()`你觉得会是啥？

```
"既然箭头函数内的this是由外层作用域决定的，那这里外层作用域是window，当然this.type就是'window'咯"
```

咦～

还记得我之前说过的，`class`的本质是个函数吗？所以你碰到`class`内有箭头函数的题目，把它当成构造函数创建对象来处理就可以了。

在构造函数中如果使用了箭头函数的话，`this`指向的就是这个实例对象。

因此将`class`转化为构造函数的话，伪代码为：

```js
function Cat () {
  this.type = 'class'
  this.getType = () => {
    console.log(this.type)
    console.log(type)
  }
}
Cat.prototype.constructor = function () {
  this.name = 'guaiguai'
  var type = 'constructor'
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.constructor()
guaiguai.getType()
console.log(guaiguai)

```

别的都好理解，这里为啥，`constructor`要放在原型对象中，并且要在`var guaiguai = new Cat()`下面再调用它呢？

嘻嘻，还记得在`2.2`中我们就说过了吗，任何放在类上的方法都相当于写在原型对象上，并且在使用类的时候，会隐式执行`constructor`函数。这两段代码就是为了模拟这个操作。

这样的话，上面👆两个题目的结果都是：

```
'class'
'window'
Cat {type: "class", name: "guaiguai", getType: ƒ}
```



##### 2.7 和2.5的扩展一样

如果在`class`中存在两个相同的属性或者方法会怎么样呢 🤔️？

```js
class Cat {
  constructor () {
    this.name = 'cat1'
  }
  name = 'cat2'
  getName = function  () {
    console.log(this.name)
  }
}
var cat = new Cat()
cat.getName()
复制代码
```

这道题中，我们调用`getName`方法，打印出的会是：

```
'cat1'
复制代码
```

所以可以看出`constructor`中定义的相同名称的属性和方法会覆盖在`class`里定义的。

##### 2.9

好吧 😅，现在可以加大难度了：

```js
class Cat {
  constructor () {
    this.name = 'guaiguai'
    var type = 'constructor'
    this.getType = () => {
      console.log(this.type)
      console.log(type)
    }
  }
  type = 'class'
  getType = () => {
    console.log(this.type)
    console.log(type)
  }
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.getType()
console.log(guaiguai)
```

首先我们很清楚，如果`type`打印出的是`window`那就表示使用的是第二个`getType`，否则表示用的是第一个`getType`。

##### 总结-class

来吧，对`class`实现封装也来做个总结呗：

**(一) class的基本概念：**

- 当你使用`class`的时候，它会默认调用`constructor`这个函数，来接收一些参数，并构造出一个新的实例对象(`this`)并将它返回。
- 如果你的`class`没有定义`constructor`，也会隐式生成一个`constructor`方法

**(二) class中几种定义属性的区别：**：

- 在`constructor`中`var`一个变量，它只存在于`constructor`这个构造函数中
- 在`constructor`中使用`this`定义的属性和方法会被定义到实例上
- 在`class`中使用`=`来定义一个属性和方法，效果与第二点相同，会被定义到实例上
- 在`class`中直接定义一个方法，会被添加到`原型对象prototype`上
- 在`class`中使用了`static`修饰符定义的属性和方法被认为是静态的，被添加到类本身，不会添加到实例上

**(三) other:**

- `class`本质虽然是个函数，但是并不会像函数一样提升至作用域最顶层
- 如遇`class`中箭头函数等题目请参照构造函数来处理
- 使用`class`生成的实例对象，也会有沿着原型链查找的功能

### 12.继承

传送门：

[💦【何不三连】做完这48道题彻底弄懂JS继承(1.7w字含辛整理-返璞归真) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904098941108232#heading-0)

**继承就是子类可以使用父类的所有功能，并且对这些功能进行扩展。**

比如我有个构造函数`A`，然后又有个构造函数`B`，但是`B`想要使用`A`里的一些属性和方法，一种办法就是让我们自身化身为`CV侠`，复制粘贴一波。还有一种就是利用继承，我让`B`直接继承了`A`里的功能，这样我就能用它了。

今天要介绍的八种继承方式在目录中都已经列举出来了。

不着急，从浅到深咱一个个来看。

#### 1. 原型链继承

##### 习题1

**将子类的原型对象指向父类的实例**

```js
function Parent () {
  this.name = 'Parent'
  this.sex = 'boy'
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child () {
  this.name = 'child'
}
Child.prototype = new Parent()

var child1 = new Child()
child1.getName()
console.log(child1)
```

好了，快告诉我答案吧，会打印出什么 🤔️ ？

```
'child'
Child {name: "child"}
复制代码
```

这...这很好理解呀

- `child1`是通过子类构造函数`Child`生成的对象，那我就有属性`name`，并且属性值也是自己的`child`
- 然后子类构造函数`Child`它的原型被指向了父类构造函数`Parent`创建出来的`"无名实例"`
- 这样的话，我`child1`就可以使用你这个`"无名实例"`里的所有属性和方法了呀，因此`child1.getName()`有效。并且打印出`child`。
- 另外由于`sex、getName`都是`Child`原型对象上的属性，所以并不会表现在`child1`上。

这看着不就是之前都讲到过的内容嘛？



![image-20220517203407678](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220517203407678.png)

##### 习题2

不知道你们在看到**原型链继承**这个词语的时候，第一时间想到的是什么？

有没有和我一样，想到的是把子类的原型对象指向父类的原型对象的😂：

```
Child.prototype = Parent.prototype
复制代码
```

和我一样的举个手给我看下🙋‍♂️，😂

之后我就为我xx似的想法感到惭愧...

如果我只能拿到父类原型链上的属性和方法那也太废了吧，我可不止这样，我还想拿到父类构造函数上的属性。

所以这道题：

```js
function Parent () {
  this.name = 'Parent'
  this.sex = 'boy'
}
Parent.prototype.getSex = function () {
  console.log(this.sex)
}
function Child () {
  this.name = 'child'
}
Child.prototype = Parent.prototype

var child1 = new Child()
child1.getSex()
console.log(child1)

```

结果为：

```
undefined
Child {name: "child"}
复制代码
```

![image-20220517204010704](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220517204010704.png)

你可以结合上面👆的那张图，自个儿脑补一下，`child1`它的原型链现在长啥样了。

解析：

- `child1`上能使用的属性和方法只有`name、getSex`，所以`getSex`打印出的会是`undefined`
- 打印出的`child1`只有`name`属性，`getSex`为原型上的方法所以并不会表现出来。

这道题是个错误的做法啊 😂

我只是为了说明一下，为什么**原型链继承**是要用`Child.prototype = new Parent()`这种方式。

##### 习题3 做错了 重点看看

child1.sex = 'girl'这段代码分析错误

```js
function Parent (name) {
  this.name = name
  this.sex = 'boy'
  this.colors = ['white', 'black']
}
function Child () {
  this.feature = ['cute']
}
var parent = new Parent('parent')
Child.prototype = parent

var child1 = new Child('child1')
child1.sex = 'girl'
child1.colors.push('yellow')
child1.feature.push('sunshine')

var child2 = new Child('child2')

console.log(child1)
console.log(child2)

console.log(child1.name)
console.log(child2.colors)

console.log(parent)
```

答案：

```
Child{ feature: ['cute', 'sunshine'], sex: 'girl' }
Child{ feature: ['cute'] }

'parent'
['white', 'black', 'yellow']

Parent {name: "parent", sex: 'boy', colors: ['white', 'black', 'yellow'] }
复制代码
```

解析：

- `child1`在创建完之后，就设置了`sex`，并且给`colors`和`feature`都`push`了新的内容。
- `child1.sex = 'girl'`这段代码相当于是给`child1`这个实例对象新增了一个`sex`属性。相当于是：原本我是没有`sex`这个属性的，我想要获取就得拿原型对象`parent`上的`sex`，但是现在你加了一句`child1.sex`就等于是我自己也有了这个属性了，就不需要你原型上的了，所以并不会影响到原型对象`parent`上😊。
- 但是`child1.colors`这里，注意它的操作，它是直接使用了`.push()`的，也就是说我得先找到`colors`这个属性，发现实例对象`parent`上有，然后就拿来用了，之后执行`push`操作，所以这时候改变的是原型对象`parent`上的属性，会影响到后续所有的实例对象。(这里你会有疑问了，凭什么`sex`就是在实例对象`child`上新增，而我`colors`不行，那是因为操作的方式不同，`sex`那里是我不管你有没有，反正我就直接用`=`来覆盖你了，可是`push`它的前提是我得先有`colors`且类型是数组才行，不然你换成没有的属性，比如一个名为`clothes`的属性，`child1.clothes.push('jacket')`它直接就报错了，如果你使用的是`child1.colors = ['yellow']`这样才不会影响`parent`)
- 而`feature`它是属于`child1`实例自身的属性，它添加还是减少都不会影响到其他实例。
- 因此`child1`打印出了`feature`和`sex`两个属性。(`name`和`colors`属于原型对象上的属性并不会被表现出来)
- `child2`没有做任何操作，所以它打印出的还是它自身的一个`feature`属性😁。
- `child1.name`是原型对象`parent`上的`name`，也就是`'parent'`，虽然我们在`new Child`的时候传递了`'child1'`，但它显然是无效的，因为接收`name`属性的是构造函数`Parent`，而不是`Child`。
- `child2.colors`由于用的也是原型对象`parent`上的`colors`，又由于之前被`child1`给改变了，所以打印出来的会是`['white', 'black', 'yellow']`
- 将最后的原型对象`parent`打印出来，`name`和`sex`没变，`colors`却变了。



![image-20220517205535273](C:\Users\FengXiao7\AppData\Roaming\Typora\typora-user-images\image-20220517205535273.png)

##### 总结-原型链继承

现在我们就可以得出**原型链继承**它的优点和缺点了

**优点：**

- 继承了父类的模板，又继承了父类的原型对象

**缺点：**

- 如果要给子类的原型上新增属性和方法，就必须放在`Child.prototype = new Parent()`这样的语句后面
- 无法实现多继承(因为已经指定了原型对象了)
- 来自原型对象的所有属性都被共享了，这样如果不小心修改了原型对象中的引用类型属性，那么所有子类创建的实例对象都会受到影响(这点从修改`child1.colors`可以看出来)
- 创建子类时，无法向父类构造函数传参数(这点从`child1.name`可以看出来)

这...这看到没，压根就不需要记，想想霖呆呆出的这道变态的题面试的时候被问到脱口就来了。

#### 2. instanceof

##### 2.1 题目一

这道题主要是想介绍一个重要的运算符: **instanceof**

先看看官方的简介：

**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

再来看看通俗点的简介：

```
a instanceof B
实例对象a instanceof 构造函数B
```

检测`a`的原型链`(__proto__)`上是否有`B.prototype`，有则返回`true`，否则返回`false`。

上题吧：

```js
function Parent () {
  this.name = 'parent'
}
function Child () {
  this.sex = 'boy'
}
Child.prototype = new Parent()
var child1 = new Child()

console.log(child1 instanceof Child)
console.log(child1 instanceof Parent)
console.log(child1 instanceof Object)
```

结果为：

```
true
true
true
```

这里就利用了前面👆提到的原型链继承，而且三个构造函数的原型对象都存在于`child1`的原型链上。

也就是说，左边的`child1`它会向它的原型链中不停的查找，看有没有右边那个构造函数的原型对象。

例如`child1 instanceof Child`的查找顺序：

```
child1 -> child1.__proto__ -> Child.prototype
复制代码
```

`child1 instanceof Parent`的查找顺序：

```
child1 -> child1.__proto__ -> Child.prototype
-> Child.prototype.__proto__ -> Parent.prototype
```

##### 2.2 题目二

（了解`isPrototypeOf()`的使用）

传送门：[类检查："instanceof" (javascript.info)](https://zh.javascript.info/instanceof)

既然说到了`instanceof`，那么就不得不提一下`isPrototypeOf`这个方法了。

它属于`Object.prototype`上的方法，这点你可以将`Object.prototype`打印在控制台中看看。

`isPrototypeOf()`的用法和`instanceof`相反。

它是用来判断指定对象`object1`是否存在于另一个对象`object2`的原型链中，是则返回`true`，否则返回`false`。

例如还是上面👆这道题，我们将要打印的内容改一下：

```js
function Parent () {
  this.name = 'parent'
}
function Child () {
  this.sex = 'boy'
}
Child.prototype = new Parent()
var child1 = new Child()

console.log(Child.prototype.isPrototypeOf(child1))
console.log(Parent.prototype.isPrototypeOf(child1))
console.log(Object.prototype.isPrototypeOf(child1))
```

这里输出的依然是三个`true`：

```
true
true
true
复制代码
```

判断的方式只要把**原型链继承instanceof查找思维导图**这张图反过来查找即可。

#### 3. 构造继承

了解了最简单的**原型链继承**，再让我们来看看**构造继承**呀，也叫做**构造函数继承**。

在子类构造函数内部使用`call或apply`来调用父类构造函数

##### 3.1

```js
function Parent (name) {
  this.name = name
}
function Child () {
  this.sex = 'boy'
  Parent.call(this, 'child')
}
var child1 = new Child()
console.log(child1)
```

`child1`中会有哪些属性呢？

首先`sex`我们知道肯定会有的，毕竟它就是构造函数`Child`里的。

其次，我们使用了`Parent.call(this, 'child')`，`.call`函数刚刚已经说过了，它是会立即执行的，而这里又用了`.call`来改变`Parent`构造函数内的指向，所以我们是不是可以将它转化为伪代码：

```
function Child () {
	this.sex = 'boy'
	// 伪代码
	this.name = 'child'
}
```

你就理解为相当于是直接执行了`Parent`里的代码。使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。

所以构造继承的原理就是：

**在子类构造函数内部使用`call或apply`来调用父类构造函数**

同样的，来写下伪代码：

```
function Child () {
    Parent.call(this, ...arguments)
}
```

（`arguments`表示的是你可以往里面传递参数，当然这只是伪代码）

##### 3.2

```js
function Parent (name) {
  this.name = name
}
function Child () {
  this.sex = 'boy'
  Parent.call(this, 'good boy')
  this.name = 'bad boy'
}
var child1 = new Child()
console.log(child1)

```

重复定义了两个相同名称的属性，当然是后面的覆盖前面的啦。

所以结果为：

```js
Child {sex: "boy", name: "bad boy"}
```

##### 3.3 构造继承优点 重点看看

解决了**原型链继承**中子类共享父类引用对象的问题

刚刚的题目都是一些基本数据类型，让我来加上引用类型看看

```js
function Parent (name, sex) {
  this.name = name
  this.sex = sex
  this.colors = ['white', 'black']
}
function Child (name, sex) {
  Parent.call(this, name, sex)
}
var child1 = new Child('child1', 'boy')
child1.colors.push('yellow')

var child2 = new Child('child2', 'girl')
console.log(child1)
console.log(child2)
```

这道题看着和`1.3`好像啊，没错，在父类构造函数中有一个叫`colors`的数组，它是地址引用的。

在**原型链继承**中我们知道，子类构造函数创建的实例是会查找到原型链上的`colors`的，而且改动它会影响到其它的实例，这是**原型链继承**的一大缺点。

而现在呢？你看看使用了**构造继承**，结果为：

```
Child{ name: 'child1', sex: 'boy', colors: ['white', 'black', 'yellow'] }
Child{ name: 'child2', sex: 'girl', colors: ['white', 'black'] }
复制代码
```

我们发现修改`child1.colors`并不会影响到其它的实例(`child2`)耶。

这里的原因其实我们前面也说了：

使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。

所以现在`child1`和`child2`现在分别有它们各自的`colors`了，就不共享了。

而且这种拷贝属于深拷贝，验证的方式是你可以把`colors`数组中的每一项改为一个对象，然后修改它看看。

```
function Parent () {
	//...
	this.colors = [{ title: 'white' }, { title: 'black' }]
}
```

因此我们可以得出**构造继承**的优点：

- 解决了原型链继承中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数

##### 3.4 构造继承缺点一

构造继承**只能**继承父类的实例属性和方法，**不能**继承父类原型的属性和方法

采用了这种**构造继承**的方式，能不能继承父类原型链上的属性呢？

来看下面👇这道题目

```js
function Parent (name) {
  this.name = name
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child () {
  this.sex = 'boy'
  Parent.call(this, 'good boy')
}
Child.prototype.getSex = function () {
  console.log(this.sex)
}
var child1 = new Child()
console.log(child1)
child1.getSex()
child1.getName()
```

我给子类和父类的原型对象上都分别加了一个方法，然后调用它们。

结果竟然是：

```
Child {sex: "boy", name: "good boy"}
'boy'
Uncaught TypeError: child1.getName is not a function
```

- `sex、name`属性都有这个我们都可以理解
- `getSex`属于`Child`构造函数原型对象上的方法，我们肯定是能用它的，这个也好理解
- 那`getName`呢？它属于父类构造函数原型对象上的方法，报错了？怎么滴？我子类不配使用你啊？

你确实是不配使用我。

你使用`Parent.call(this, 'good boy')`只不过是让你复制了一下我构造函数里的属性和方法，可没说能让你复制我原型对象的啊～年轻人，不要这么贪嘛。

所以我们可以看出**构造继承**一个最大的缺点，那就是：

小气！

其实是：构造继承**只能**继承父类的实例属性和方法，**不能**继承父类原型的属性和方法

##### 3.5 构造继承缺点二

实例并不是父类的实例，只是子类的实例。

```js
function Parent (name) {
  this.name = name
}
function Child () {
  this.sex = 'boy'
  Parent.call(this, 'child')
}
var child1 = new Child()

console.log(child1)
console.log(child1 instanceof Child)
console.log(child1 instanceof Parent)
console.log(child1 instanceof Object)
```

结果为：

```
Child {sex: "boy", name: "child"}
true
false
true
复制代码
```

- 第一个`true`很好理解啦，我就是你生的，你不`true`谁`true`
- 第二个为`false`其实也很好理解啦，想想刚刚的`5.3`，我连你父类原型上的方法都不能用，那我和你可能也没有关系啦，我只不过是复制了你函数里的属性和方法而已。
- 第三个`true`，必然的，实例的原型链如果没有发生改变的话最后都能找到`Object.prototype`啦。

##### 总结-构造继承

构造继承总结来说：

**优点：**

- 解决了原型链继承中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数(见题目`3.3`)

**缺点：**

- 构造继承**只能**继承父类的实例属性和方法，**不能**继承父类原型的属性和方法(见题目`3.4`)
- 实例并不是父类的实例，只是子类的实例(见题目`3.5`)
- **无法实现函数复用**，每个子类都有父类实例函数的副本，影响性能



#### 4.组合继承

```
// 原型链继承
Child.prototype = new Parent()
// 构造继承
function Child () {
  Parent.call(this, ...arguments)
}
复制代码
```

...思考中🤔...

看到这两段伪代码，我好像有所顿悟了，不就是按照伪代码里写的，把这两种继承组合在一起吗？

哇！这都被我猜中了，搜索一下组合继承的概念，果然就是这样。

**组合继承的概念：**

组合继承就是将原型链继承与构造函数继承组合在一起，从而发挥两者之长的一种继承模式。

**思路：**

- 使用**原型链继承**来保证子类能继承到父类原型中的属性和方法
- 使用**构造继承**来保证子类能继承到父类的实例属性和方法

**基操：**

- 通过`call/apply`在子类构造函数内部调用父类构造函数
- 将子类构造函数的原型对象指向父类构造函数创建的一个匿名实例
- 修正子类构造函数原型对象的`constructor`属性，将它指向子类构造函数

基操中的第一点就是**构造继承**，第二点为**原型链继承**，第三点其实只是一个好的惯例，在后面的题目会细讲到它。

##### 4.1 开放题 推荐看原文

我的答案：做错了，Child.prototype=new Parent()//原型继承要放在Child.prototype.getSex=function()之前

```js
function Child(name){
    this.sex='boy'
    Parent.call(this,name)//构造继承
}
function Parent(name){
    this.name=name
}
Child.prototype.getSex=function(){
    console.log(this.sex)
}
Parent.prototype.getName=function(){
    console.log(this.name)
}

Child.prototype=new Parent()//原型继承


var child1 = new Child('child1')
var parent1 = new Parent('parent1')
console.log(child1) // Child{ name: 'child1', sex: 'boy' }
console.log(parent1)// Parent{ name: 'parent1' }
child1.getName()    // 'child1'
child1.getSex()     // 'boy'
parent1.getName()   // 'parent1'
parent1.getSex()    // Uncaught TypeError: parent1.getSex is not a function

```



##### 4.2  constructor

![image-20220518135335293](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518135335293.png)

 constructor实际就是原型对象上的一个属性，指向的是构造函数。

所以我们是不是可以有这么一层对应关系：

```js
guaiguai.__proto__ = Cat.prototype
Cat.prototype.constructor = Cat
guaiguai.__proto__.constructor = Cat
```




```js
function Parent (name) {
  this.name = name
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child (name) {
  this.sex = 'boy'
  Parent.call(this, name)
}
Child.prototype = new Parent()
Child.prototype.getSex = function () {
  console.log(this.sex)
}

var child1 = new Child('child1')
var parent1 = new Parent('parent1')
console.log(child1.constructor)
console.log(parent1.constructor)
```

一时不知道答案也没关系，我直接公布一下了：

```
f Parent () {}
f Parent () {}
```

![image-20220518135913995](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518135913995.png)


总结来说：

- `constructor`它是构造函数原型对象中的一个属性，正常情况下它指向的是原型对象。
- 它并不会影响任何`JS`内部属性，只是用来标示一下某个实例是由哪个构造函数产生的而已。
- 如果我们使用了**原型链继承**或者**组合继承**无意间修改了`constructor`的指向，那么出于编程习惯，我们最好将它修改为正确的构造函数。

##### 4.4 有点难度 组合继承优点



```js
function Parent (name, colors) {
  this.name = name
  this.colors = colors
}
Parent.prototype.features = ['cute']
function Child (name, colors) {
  this.sex = 'boy'
  Parent.apply(this, [name, colors])
}
Child.prototype = new Parent()
Child.prototype.constructor = Child

var child1 = new Child('child1', ['white'])
child1.colors.push('yellow')
child1.features.push('sunshine')
var child2 = new Child('child2', ['black'])

console.log(child1)
console.log(child2)
console.log(Child.prototype)

console.log(child1 instanceof Child)
console.log(child1 instanceof Parent)
```

有了前面几题作为基础，这道题也就不难了。

答案：

```
Child{ sex: "boy", name: "child1", colors: ["white", "yellow"] }
Child{ sex: "boy", name: "child2", colors: ["black"] }
Parent{ name: undefined, colors: undefined, constructor: f Child () {} }

true
true
```

![image-20220518141953424](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518141953424.png)

解析思路：

- 两个`child`的`sex`和`name`都没啥问题，而`colors`可能会有些疑问，因为`colors`是通过**构造继承**于父类的，并且是复制出来的属性，所以改变`child1.colors`并不会影响`child2.colors`。(类似题目`3.3`)
- 而`Child.prototype`，是使用`new Parent`生成的，并且生成的时候是没有传递参数进去的，因此`name`和`colors`都是`undefined`。而且题目中又将`constructor`给修正指向了`Child`。
- 最后两个`true`，是因为`child1`可以沿着它的原型链查找到`Child.prototype`和`Parent.prototype`。(类似题目`2.1`)

现在你就可以看出**组合继承**的优点了吧，它其实就是将两种继承方式的优点给结合起来。

- 可以继承父类实例属性和方法，也能够继承父类原型属性和方法
- 弥补了原型链继承中引用属性共享的问题
- 可传参，可复用

##### 4.5 组合继承缺点

```js
function Parent(name) {
    console.log(name) // 这里有个console.log()
    this.name = name
}
function Child(name) {
    Parent.call(this, name)
}
Child.prototype = new Parent()//undefined
var child1 = new Child('child1')//child1

console.log(child1)//Child{name:child1}
console.log(Child.prototype)//Parent{name:undefined}
```

执行结果为：

```
undefined
'child1'

Child{ name: 'child1' }
Parent{ name: undefined }
```

我们虽然只调用了`new Child()`一次，但是在`Parent`中却两次打印出了`name`。

- 第一次是**原型链继承**的时候，`new Parent()`
- 第二次是**构造继承**的时候，`Parent.call()`调用的

也就是说，在使用组合继承的时候，会凭空多调用一次父类构造函数。

另外，我们想要继承**父类构造函数**里的属性和方法采用的是**构造继承**，也就是复制一份到子类实例对象中，而此时由于调用了`new Parent()`，所以`Child.prototype`中也会有一份一模一样的属性，就例如这里的`name: undefined`，可是我子类实例对象自己已经有了一份了呀，所以我怎么也用不上`Child.prototype`上面的了，那你这凭空多出来的属性不就占了内存浪费了吗？

![image-20220518142736389](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518142736389.png)

因此我们可以看出**组合继承**的缺点：

- 使用组合继承时，父类构造函数会被调用两次
- 并且生成了两个实例，子类实例中的属性和方法会覆盖子类原型(父类实例)上的属性和方法，所以增加了不必要的内存。

##### 4.6

（考察你是否理解**实例对象**上引用类型和**原型对象**上引用类型的区别）

这里可就有一个坑了，得注意了⚠️：

```js
function Parent (name, colors) {
  this.name = name
  this.colors = colors
}
Parent.prototype.features = ['cute']
function Child (name, colors) {
  Parent.apply(this, [name, colors])
}
Child.prototype = new Parent()
Child.prototype.constructor = Child

var child1 = new Child('child1', ['white'])
child1.colors.push('yellow')
child1.features.push('sunshine')
var child2 = new Child('child2', ['black'])

console.log(child1.colors)
console.log(child2.colors)
console.log(child1.features)
console.log(child2.features)
```

题目解析：

- `colors`属性虽然定义在`Parent`构造函数中，但是`Child`通过**构造继承**复制了其中的属性，所以它存在于各个实例当中，改变`child1`里的`colors`就不会影响其它地方了
- `features`是定义在**父类构造函数原型对象**中的，是比`new Parent()`还要更深一层的对象，在`child`实例还有`Child.prototype`(也就是`new Parent()`产生出了的匿名实例)上都没有`features`属性，因此它们只能去它们共有的`Parent.prototype`上面拿了，所以这时候它们就是共用了一个`features`，因此改变`child1.features`就会改变`child2.features`了。

结果为：

```
["white", "yellow"]
["black"]
["cute", "sunshine"]
["cute", "sunshine"]
复制代码
```

可是霖呆呆不对呀，你刚刚不是还说了：

**组合继承弥补了原型链继承中引用属性共享的问题**

就在题`4.4`中，都还热乎着呢？怎么这里的`features`还是没有被解决啊，它们还是共享了。

```
"冤枉啊！我从来不骗人"
```

它确实是解决了**原型链继承中引用属性共享的问题**啊，你想想这里`Child.prototype`是谁？

是不是`new Parent()`产生的那个匿名实例？而这个匿名实例中的引用类型是不是`colors`？而`colors`是不是确实不是共享的？

那就对了呀，我已经帮你解决了原型(`匿名实例`)中引用属性共享的问题了呀。

至于`features`是`Parent.prototype`上的属性，相当于是爷爷那一级别的了，这我可没法子。

##### 总结-组合继承

同样的，让我们对**组合继承**也来做个总结吧：

**实现方式：**

- 使用**原型链继承**来保证子类能继承到父类原型中的属性和方法
- 使用**构造继承**来保证子类能继承到父类的实例属性和方法

**优点：**

- 可以继承父类实例属性和方法，也能够继承父类原型属性和方法
- 弥补了原型链继承中引用属性共享的问题
- 可传参，可复用

**缺点：**

- 使用组合继承时，父类构造函数会被调用两次
- 并且生成了两个实例，子类实例中的属性和方法会覆盖子类原型(父类实例)上的属性和方法，所以增加了不必要的内存。

**constructor总结：**

- `constructor`它是构造函数原型对象中的一个属性，正常情况下它指向的是原型对象。
- 它并不会影响任何`JS`内部属性，只是用来标示一下某个实例是由哪个构造函数产生的而已。
- 如果我们使用了**原型链继承**或者**组合继承**无意间修改了`constructor`的指向，那么出于编程习惯，我们最好将它修改为正确的构造函数



#### 5.寄生组合继承

它和组合继承只有一个地方不同，组合继承中的原型继承是使用的匿名实例，

```
Child.prototype = new Parent()
```

寄生组合继承是使用的Object.create()

```js
Child.prototype = Object.create(Parent.prototype)
```

刚刚我们提了**组合继承**的缺点无非就是：

1. 父类构造函数会被调用两次
2. 生成了两个实例，在父类实例上产生了无用废弃的属性

那么有没有一种方式让我们直接跳过父类实例上的属性，而让我直接就能继承父类原型链上的属性呢？

也就是说，我们需要一个**干净**的实例对象，来作为子类的原型。并且这个**干净**的实例对象还得能继承父类原型对象里的属性。

咦～说到**干净**的对象，我就想到了一个方法：`Object.create()`。

##### 5.1

```js
function Parent (name) {
  this.name = name
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child (name) {
  this.sex = 'boy'
  Parent.call(this, name)
}
// 与组合继承的区别
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

var child1 = new Child('child1')

console.log(child1) // Child{ sex: "boy", name: "child1" }
child1.getName() // "child1"

console.log(child1.__proto__) // Parent{}
console.log(Object.create(null)) // {}
console.log(new Object()) // {}
```

可以看到，上面👆这道题就是一个标准的**寄生组合继承**，它与**组合继承**的区别仅仅是`Child.prototype`不同。

我们使用了`Object.create(Parent.prototype)`创建了一个空的对象，并且这个对象的`__proto__`属性是指向`Parent.prototype`的。



题目解析：

- 使用**寄生组合继承**，`child1`不仅仅有自己的实例属性`sex`，而且还复制了父类中的属性`name`
- **寄生组合继承**使得实例`child1`能通过原型链查找，使用到`Parent.prototype`上的方法，因此打印出`child1`。

##### 5.2

```js
function Parent(name) {
    this.name = name
    this.face = 'city'
    this.colors = ['white', 'black']
}
Parent.prototype.features = ['cute']
Parent.prototype.getFeatures = function () {
    console.log(this.features)
}
function Child(name) {
    Parent.call(this, name)
    this.sex = 'boy'
    this.face = 'smile'
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

var child1 = new Child('child1')
child1.colors.push('yellow')
var child2 = new Child('child2')
child2.features = ['sunshine']

console.log(child1)//Child{name:child1,face:smile,sex:boy,colors:[w,b,y]}
console.log(child2)//Child{name:child2,face:smile,sex:boy,colors:[w,b],features:['sunshine']}
child1.getFeatures()//[cute]
child2.getFeatures()//[sunshine]
```



- `name、face、sex`三个属性都没有啥问题，要注意的只是`face`属性，后面写的会覆盖前面的(类似题目`3.2`)
- `colors`属性是通过**构造继承**复制过来的，所以改变`child1.colors`对其他实例没有影响，这个说过很多次了。
- 要注意的就是这里的`features`，在没有执行`child2.features = ['sunshine']`这段代码之前，`child1`和`child2`都是共用原型链上的`features`，但是执行了这段代码之后，就相当于是给`child2`对象上新增了一个名为`features`属性，所以这时候`child2`取的就是它自身的了。




##### 总结-寄生组合继承

**寄生组合继承**算是`ES6`之前一种比较完美的继承方式吧。

它避免了**组合继承**中调用两次父类构造函数，初始化两次实例属性的缺点。

所以它拥有了上述所有继承方式的优点：

- 只调用了一次父类构造函数，只创建了一份父类属性
- 子类可以用到父类原型链上的属性和方法
- 能够正常的使用`instanceOf`和`isPrototypeOf`方法




#### 6. 原型式继承

#### 7. 寄生式继承

6和7都比较简单，推荐看原文

[💦【何不三连】做完这48道题彻底弄懂JS继承(1.7w字含辛整理-返璞归真) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904098941108232#heading-31)

[💦【何不三连】做完这48道题彻底弄懂JS继承(1.7w字含辛整理-返璞归真) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904098941108232#heading-35)

#### 8. 混入方式继承多个对象

过五关斩六将，咱终于到了`ES5`中的要讲的最后一种继承方式了。

这个**混入方式继承**其实很好玩，之前我们一直都是以一个子类继承一个父类，而**混入方式继承**就是教我们如何一个子类继承多个父类的。

在这边，我们需要用到`ES6`中的方法`Object.assign()`。

它的作用就是可以把多个对象的属性和方法拷贝到目标对象中，若是存在同名属性的话，后面的会覆盖前面。(当然，这种拷贝是一种浅拷贝啦)

```js
function Child () {
    Parent.call(this)
    OtherParent.call(this)
}
Child.prototype = Object.create(Parent.prototype)
Object.assign(Child.prototype, OtherParent.prototype)
Child.prototype.constructor = Child

```



##### 8.1

```js
function Parent (sex) {
  this.sex = sex
}
Parent.prototype.getSex = function () {
  console.log(this.sex)
}
function OtherParent (colors) {
  this.colors = colors
}
OtherParent.prototype.getColors = function () {
  console.log(this.colors)
}
function Child (sex, colors) {
  Parent.call(this, sex)
  OtherParent.call(this, colors) // 新增的父类
  this.name = 'child'
}
Child.prototype = Object.create(Parent.prototype)
Object.assign(Child.prototype, OtherParent.prototype) // 新增的父类原型对象
Child.prototype.constructor = Child

var child1 = new Child('boy', ['white'])
child1.getSex()
child1.getColors()
console.log(child1)
```

这里就是采用了混入方式继承，在题目中标出来的地方就是不同于**寄生组合继承**的地方。

现在的`child1`不仅复制了`Parent`上的属性和方法，还复制了`OtherParent`上的。

而且它不仅可以使用`Parent.prototype`的属性和方法，还能使用`OtherParent.prototype`上的。

结果：

```
'boy'
['white']
{ name: 'child', sex: 'boy', colors: ['white'] }
```

![image-20220518155153951](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518155153951.png)


##### 8.2 错了 重点看看

代码和8.1一样，输出不一样

```js
console.log(Child.prototype.__proto__ === Parent.prototype)//true
console.log(Child.prototype.__proto__ === OtherParent.prototype)//false
console.log(child1 instanceof Parent)//true
console.log(child1 instanceof OtherParent)//false
```

![image-20220518161352657](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518161352657.png)

如果我再增加一个父亲：

```js
function OtherParent_1(colors_1) {
    this.colors_1 = colors_1
}
OtherParent_1.prototype.getColors_1 = function () {
    console.log(this.colors_1)
}
```



```js
Object.assign(Child.prototype, OtherParent.prototype,OtherParent_1.prototype) 
```

![image-20220518161748075](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518161748075.png)





![image-20220518160621099](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220518160621099.png)



#### 9.class中的继承 都看看吧

构造函数中主要的几种继承方式都已经介绍的差不多了，接下来就让我们看看`ES6`中`class`的继承吧。

在`class` 中继承主要是依靠两个东西：

- `extends`
- `super`

而且对于该继承的效果和之前我们介绍过的**寄生组合继承**方式一样。（没错，就是那个最屌的继承方式）

##### 9.1

既然它的继承和**寄生组合继承方式**一样，那么让我们将题目`5.1`的题目改造一下，用`class`的继承方式来实现它。

```js
class Parent {
  constructor (name) {
    this.name = name
  }
  getName () {
    console.log(this.name)
  }
}
class Child extends Parent {
  constructor (name) {
    super(name)
    this.sex = 'boy'
  }
}
var child1 = new Child('child1')
console.log(child1)
child1.getName()

console.log(child1 instanceof Child)
console.log(child1 instanceof Parent)
```

结果如下：

```
Child{ name: 'child1', sex: 'boy' }
'child1'
true
true
```

##### 9.2 `extends`的基本作用

(理解`extends`的基本作用)

可以看到上面👆那道题，我们用到了两个关键的东西：`extends`和`super`。

`extends`从字面上来看还是很好理解的，对某个东西的延伸，继承。

那如果我们单单只用`extends`不用`super`呢？

```js
class Parent {
  constructor (name) {
    this.name = name
  }
  getName () {
    console.log(this.name)
  }
}
class Child extends Parent {
  // constructor (name) {
  //   super(name)
  //   this.sex = 'boy'
  // }
  sex = 'boy' // 实例属性sex放到外面来
}
var child1 = new Child('child1')
console.log(child1)
child1.getName()
```

其实这里的执行结果和没有隐去之前一样。

执行结果：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/21/170fc8317da4336e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



那我们是不是可以认为：

```
class Child extends Parent {}

// 等同于
class Child extends Parent {
    constructor (...args) {
        super(...args)
    }
}
复制代码
```

OK👌，其实这一步很好理解啦，还记得之前我们就提到过，在`class`中如果没有定义`constructor`方法的话，这个方法是会被默认添加的，那么这里我们没有使用`constructor`，它其实已经被隐式的添加和调用了。

所以我们可以看出`extends`的作用：

- `class`可以通过`extends`关键字实现继承父类的所有属性和方法
- 若是使用了`extends`实现继承的子类内部没有`constructor`方法，则会被默认添加`constructor`和`super`。



##### 9.3 `super`的基本作用

(理解`super`的基本作用)

通过上面那道题看来，`constructor`貌似是可有可无的角色。

那么`super`呢，它在 `class`中扮演的是一个什么角色 🤔️？

还是上面的题目，但是这次我不使用`super`，看看会有什么效果：

```
class Parent {
  constructor () {
    this.name = 'parent'
  }
}
class Child extends Parent {
  constructor () {
    // super(name) // 把super隐去
  }
}
var child1 = new Child()
console.log(child1)
child1.getName()
复制代码
```

哈哈哈，现在你保存刷新页面，就会发现它报错了：

```
Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    at new Child
复制代码
```

你品你细细品。

大致意思就是你必须得在`constructor`中调用一下`super`函数。

这样说来，`constructor`和`super`是一对好基友啊...

`super`函数咱还是不能省，很重要啊。

然后再看了看它的写法，有点像是给父级类中传递参数的感觉啊 😄。

唔...如果你这样想的话算是猜对了一部分吧。这其实和`ES6`的继承机制有关。

- 我们知道在`ES5`中的继承(例如**构造继承、寄生组合继承**) ，实质上是先创造子类的实例对象`this`，然后再将父类的属性和方法添加到`this`上(使用的是`Parent.call(this)`)。
- 而在`ES6`中却不是这样的，它实质是**先创造父类的实例对象`this`(也就是使用`super()`)，然后再用子类的构造函数去修改`this`**。

通俗理解就是，子类必须得在`constructor`中调用`super`方法，否则新建实例就会报错，因为子类自己没有自己的`this`对象，而是继承父类的`this`对象，然后对其加工，如果不调用`super`的话子类就得不到`this`对象。

哇哦～

[果然是好基友～]

这道题介绍的是`super`的基本作用，下面来说说它的具体用法吧。



##### 9.4 `super`当作函数调用时 容易绕昏

(`super`当作函数调用时)

`super`其实有两种用法，一种是当作函数来调用，还有一种是当做对象来使用。

之前那道题就是将它当成函数来调用的，而且我们知道在`constructor`中还必须得执行`super()`。

其实，**当`super`被当作函数调用时，代表着父类的构造函数**。

虽然它代表着父类的构造函数，但是返回的却是子类的实例，也就是说`super`内部的`this`指向的是`Child`。

让我们来看道题验证一下：

(`new.target`指向当前正在执行的那个函数，你可以理解为`new`后面的那个函数)

```js
class Parent {
  constructor () {
    console.log(new.target.name)
  }
}
class Child extends Parent {
  constructor () {
    var instance = super()
    console.log(instance)
    console.log(instance === this)
  }
}
var child1 = new Child()

var parent1 = new Parent()

console.log(child1)
console.log(parent1)
```

这道题中，我在父类的`constructor`中打印出`new.target.name`。

并且用了一个叫做`instance`的变量来盛放`super()`的返回值。

而刚刚我们已经说了，`super`的调用代表着父类构造函数，那么这边我在调用`new Child`的时候，它里面也执行了父类的`constructor`函数，所以`console.log(new.target.name)`肯定被执行了两遍了(一遍是`new Child`，一遍是`new Parent`)

所以这里的执行结果为：

```
'Child'
Child{}
true

'Parent'

Child{}
Parent{}

```

- `new.target`代表的是`new`后面的那个函数，那么`new.target.name`表示的是这个函数名，所以在执行`new Child`的时候，由于调用了`super()`，所以相当于执行了`Parent`中的构造函数，因此打印出了`'Child'`。
- 另外，关于`super()`的返回值`instance`，刚刚已经说了它返回的是子类的实例，因此`instance`会打印出`Child{}`；并且`instance`和子类`construtor`中的`this`相同，所以打印出`true`。
- 而执行`new Parent`的时候，`new.target.name`打印出的就是`'Parent'`了。
- 最后分别将`child1`和`parent1`打印出来，都没什么问题。

通过这道题我们可以看出：

- `super`当成函数调用时，代表父类的构造函数，且返回的是子类的实例，也就是此时`super`内部的`this`指向子类。
- 在子类的`constructor`中`super()`就相当于是`Parent.constructor.call(this)`



##### 9.5  `super`当成函数调用时的限制

(`super`当成函数调用时的限制)

刚刚已经说明了`super`当成函数调用的时候就相当于是用`call`来改变了父类构造函数中的`this`指向，那么它的使用有什么限制呢？

- **子类`constructor`中如果要使用`this`的话就必须放到`super()`之后**
- **`super`当成函数调用时只能在子类的`construtor`中使用**

来看看这里：

```js
class Parent {
  constructor (name) {
    this.name = name
  }
}
class Child extends Parent {
  constructor (name) {
    this.sex = 'boy'
    super(name)
  }
}
var child1 = new Child('child1')
console.log(child1)
```

你觉得这里会打印出什么呢 🤔️？

其实这里啥都不会打印，控制台是红色的。

报了个和`7.3`一样的错：

```
Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    at new Child
```

这也就符合了刚刚说到的第一点：子类`constructor`中如果要使用`this`的话就必须放到`super()`之后。

这点其实非常好理解，还记得`super`的作用吗？在`constructor`中必须得有`super()`，它就是用来产生实例`this`的，那么再调用它之前，肯定是访问不到`this`的啦。

也就是在`this.sex = 'boy'`这一步的时候就已经报错了。

至于第二点，`super`被当成函数来调用的话就必须得放到`constructor`中，在其它的地方使用它就是我们接下来要说的`super`当成对象使用的情况。



##### 9.6 `super`当成对象来使用时 没遇见过这种写法

(`super`当成对象来使用时)

`super`如果当成一个对象来调用的话，唔...那也可能存在于`class`里的不同地方呀。

比如`constructor、子类实例方法、子类构造方法`，在这些地方它分别指代的是什么呢？

我们只需要记住：

- **在子类的普通函数中`super`对象指向父类的原型对象**
- **在子类的静态方法中`super`对象指向父类**

依靠着这个准则，我们来做做下面👇这道题：

```js
class Parent {
  constructor (name) {
    this.name = name
  }
  getName () {
    console.log(this.name)
  }
}
Parent.prototype.getSex = function () {
	console.log('boy')
}
Parent.getColors = function () {
  console.log(['white'])
}
class Child extends Parent {
  constructor (name) {
    super(name)
    super.getName()
  }
  instanceFn () {
    super.getSex()
  }
  static staticFn () {
    super.getColors()
  }
}
var child1 = new Child('child1')
child1.instanceFn()
Child.staticFn()
console.log(child1)
```

通过学习[《【何不三连】比继承家业还要简单的JS继承题-封装篇(牛刀小试)》](https://juejin.cn/post/6844904094948130824)我们知道各个方法所在的位置：

- `getName`为父类原型对象上的方法
- `getSex`为父类原型对象上的方法
- `getColors`为父类的静态方法
- `instanceFn`为子类原型对象上方法
- `staticFn`为子类的静态方法

题目分析：

- 在使用`new Child('child1')`创建`child1`的时候，会执行子类`constructor`中的方法，因此会执行`super.getName()`，而依靠准则一，此时的`constructor`中的第二个`super`指向的是父类的原型对象，因此此时`super.getName()`会被成功调用，并打印出`'child1'`。(第一个`super`是当成函数来调用)
- 当`child1`创建完之后，执行了`child1.instanceFn()`，这时候依据准则一，`instanceFn`函数中的`super`指向的还是父类的原型对象，因此`super.getSex()`也会被成功调用，并打印出`'boy'`。
- `staticFn`属于子类的静态方法，所以需要使用`Child.staticFn()`来调用，且依据准则二，此时`staticFn`中的`super`指向的是父类，也就是`Parent`这个类，因此调用其静态方法`getColors`成立，打印出`['white']`。
- 最后需要打印出`child1`，我们只需要知道哪些是`child1`的实例属性和方法就可以了，通过比较很容易就发现，`child1`中就只有一个`name`属性是通过调用`super(name)`从父级那里复制来的，其它方法都不能被`child1`"表现"出来，但是可以调用。

所以执行结果为：

```
'child1'
'boy'
['white']
Child{ name: 'child1' }
```

##### 9.7 `super`当成对象调用父类方法时`this`的指向

```js
class Parent {
  constructor () {}
}
Parent.prototype.sex  = 'boy'
Parent.prototype.getSex = function () {
  console.log(this.sex)
}
class Child extends Parent {
  constructor () {
    super()
    this.sex = 'girl'
    super.getSex()
  }
}
var child1 = new Child()
console.log(child1)
```

现在父类原型对象和子类实例对象`child1`上都有`sex`属性，且不相同。

如果按照`this`指向来看，调用`super.getSex()`打印出的应该是`Parent.prototype`上的`sex`，`'boy'`。

就像是这样调用一样：`Parent.prototype.getSex()`。

但是结果却是：

```
'girl'
Child{ sex: 'girl' }
```

唔...其实扯了这么一大堆，我只是想告诉你：

- `ES6`规定，**通过`super`调用父类的方法时，`super`会绑定子类的`this`。**

也就是说，`super.getSex()`转换为伪代码就是：

```
super.getSex.call(this)
// 即
Parent.prototype.getSex.call(this)
```

##### 9.8 题目八 了解`extends`的继承目标

`extends`后面接着的继承目标不一定要是个`class`。

`class B extends A {}`，只要`A`是一个有`prototype`属性的函数，就能被`B`继承。

由于函数都有`prototype`属性，因此`A`可以是任意函数。

来看看这一题：

```
function Parent () {
  this.name = 'parent'
}

class Child1 extends Parent {}
class Child2 {}
class Child3 extends Array {}
var child1 = new Child1()
var child2 = new Child2()
var child3 = new Child3()
child3[0] = 1

console.log(child1)
console.log(child2)
console.log(child3)
```

执行结果：

```
Child1{ name: 'parent' }
Child2{}
Child3[1]
```

- 可以继承构造函数`Parent`
- 不存在任何继承，就是一个普通的函数，所以直接继承`Function.prototype`
- 可以继承原生构造函数

（其实这里只要作为一个知道的知识点就可以了，真正使用来说貌似不常用









































## web 存储

要掌握 cookie，localStorage 和 sessionStorage。

### 1、cookie

- 本身用于浏览器和 server 通讯。
- 被“借用”到本地存储来的。
- 可用 document.cookie = '...' 来修改。（属性“**HttpOnly**”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，“跨站脚本”（XSS）也就无从谈起了。）

其缺点：

- 存储大小限制为 4KB。
- http 请求时需要发送到服务端，增加请求数量。
- 只能用 document.cookie = '...' 来修改，太过简陋。

### 2、localStorage 和 sessionStorage

- HTML5 专门为存储来设计的，最大可存 5M。
- API 简单易用， setItem getItem。
- 不会随着 http 请求被发送到服务端。

它们的区别：

- localStorage 数据会永久存储，除非代码删除或手动删除。
- sessionStorage 数据只存在于当前会话，浏览器关闭则清空。
- 一般用 localStorage 会多一些。

## Http

### 1、http 状态码

#### 1.1 状态码分类

- 1xx - 服务器收到请求。
- 2xx - 请求成功，如 200。
- 3xx - 重定向，如 302。
- 4xx - 客户端错误，如 404。
- 5xx - 服务端错误，如 500。

#### 1.2 常见状态码

- 200 - 成功。
- 301 - 永久重定向（配合 location，浏览器自动处理）。
- 302 - 临时重定向（配合 location，浏览器自动处理）。
- 304 - 资源未被修改。
- 403 - 没权限。
- 404 - 资源未找到。
- 500 - 服务器错误。
- 504 - 网关超时。

#### 1.3 关于协议和规范

- 状态码都是约定出来的。
- 要求大家都跟着执行。
- 不要违反规范，例如 IE 浏览器。

### 2、http 缓存

- 关于缓存的介绍。
- http 缓存策略（强制缓存 + 协商缓存）。
- 刷新操作方式，对缓存的影响。

#### 1 关于缓存

什么是缓存？ 把一些不需要重新获取的内容再重新获取一次

为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

哪些资源可以被缓存？ 静态资源，比如 js css img。

#### 2强制缓存

![image-20220430171930404](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430171930404.png)

Cache-Control：

- 在 Response Headers 中。
- 控制强制缓存的逻辑。
- 例如 Cache-Control: max-age=3153600（单位是秒）

Cache-Control 有哪些值：

- max-age：缓存最大过期时间。
- no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
- no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

#### 3 协商缓存（对比缓存）

- 服务端缓存策略。
- 服务端判断客户端资源，是否和服务端资源一样。
- 一致则返回 304，否则返回 200 和最新的资源。

![image-20220430172131041](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430172131041.png)



##### 资源标识：

- 在 Response Headers 中，有两种。
- Last-Modified：资源的最后修改时间。
- Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。

![image-20220430172305835](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430172305835.png)

服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。

##### Etag

![image-20220430172427595](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430172427595.png)

其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。

##### **两者比较：**

- 优先使用 Etag。
- Last-Modified 只能精确到秒级。
- 如果资源被重复生成，而内容不变，则 Etag 更精确。

#### 4.综述

![image-20220430172644349](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220430172644349.png)



#### 5 .三种刷新操作对 http 缓存的影响

- 正常操作：地址栏输入 url，跳转链接，前进后退等。
- 手动刷新：f5，点击刷新按钮，右键菜单刷新。
- 强制刷新：ctrl + f5，shift+command+r。

**正常操作：强制缓存有效，协商缓存有效。** **手动刷新：强制缓存失效，协商缓存有效。** **强制刷新：强制缓存失效，协商缓存失效。**

### 3.为了面试

传送门：

[（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904100035821575)







## React：







## Webpack：




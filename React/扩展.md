# 说明：

记录一些React扩展知识，大部分都是搬运知乎，掘金，github等等知名论坛社区。

# 1.Hooks替代Redux

传送门：

[使用React官方Hooks代替redux完整方案 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/417283750)

受文章启发，测试了下确实有效。只能说太秒了

### 优势

1. context可以按数据用途划分目录，所有相同用途的reducer相关文件均放在一个文件夹下，不同数据在不同的节点，易于维护。就是小仓库啦
2. context不需要导入combineReducers将多个reducer汇总。

### 劣势

暂时没发现！ 另外：关于数据初始化使用context时我放在store里做了；使用redux一般在reducer里做。这是编码风格问题，无所谓优劣。 没有官方调试工具，异步Action和中间件难以支持



# 2.React.memo和useMemo

## React.memo

传送门：

https://www.zhihu.com/zvideo/1455334934801596416

官网：

https://zh-hans.reactjs.org/docs/react-api.html#reactmemo

**使用React.memo来判断是否需要渲染子组件，替代类式组件PureComponet**

理解下面三个组件代码即可理解 React.memo 的使用：

- index.js：父组件
- Child.js：子组件
- ChildMemo.js：使用 React.memo 包装过的子组件

### 1、index.js

父组件进行的逻辑很简单，就是引入两个子组件，并且将三个 state 通过 props 的方式传递给子组件

父组件本身进行的逻辑会进行三个 state 的变化

理论上，父组件每次变化一个 state 都通过 props 传递给了子组件，那子组件就会重新执行渲染。（无论子组件有没有真正用到这个 props）

```jsx
import React, { useState, } from 'react';
import Child from './Child';
import ChildMemo from './Child-memo';

export default (props = {}) => {
    const [step, setStep] = useState(0);
    const [count, setCount] = useState(0);
    const [number, setNumber] = useState(0);

    const handleSetStep = () => {
        setStep(step + 1);
    }

    const handleSetCount = () => {
        setCount(count + 1);
    }

    const handleCalNumber = () => {
        setNumber(count + step);
    }


    return (
        <div>
            <button onClick={handleSetStep}>step is : {step} </button>
            <button onClick={handleSetCount}>count is : {count} </button>
            <button onClick={handleCalNumber}>numberis : {number} </button>
            <hr />
            <Child step={step} count={count} number={number} /> <hr />
            <ChildMemo step={step} count={count} number={number} />
        </div>
    );
}
```

### 2、Child.js

这个子组件本身没有任何逻辑，也没有任何包装，就是渲染了父组件传递过来的 `props.number`。

需要注意的是，子组件中并没有使用到 `props.step` 和 `props.count`，但是一旦 props.step 发生了变化就会触发重新渲染

```jsx
import React from 'react';

export default (props = {}) => {
    console.log(`--- re-render ---`);
    return (
        <div>
            {/* <p>step is : {props.step}</p> */}
            {/* <p>count is : {props.count}</p> */}
            <p>number is : {props.number}</p>
        </div>
    );
};
```

### 3、ChildMemo.js

这个子组件使用了 React.memo 进行了包装，并且通过 `isEqual` 方法判断只有当两次 props 的 `number` 的时候才会重新触发渲染，否则 `console.log` 也不会执行。

```jsx
import React, { memo, } from 'react';

const isEqual = (prevProps, nextProps) => {
    if (prevProps.number !== nextProps.number) {
        return false;
    }
    return true;
}

export default memo((props = {}) => {
    console.log(`--- memo re-render ---`);
    return (
        <div>
            {/* <p>step is : {props.step}</p> */}
            {/* <p>count is : {props.count}</p> */}
            <p>number is : {props.number}</p>
        </div>
    );
}, isEqual);
```

<img src="https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/122.gif" style="zoom: 100%"></img>

通过上图可以发现，在点击 step 和 count 的时候，props.step 和 props.count 都发生了变化，因此 `Child.js` 这个子组件每次都在重新执行渲染（`----re-render----`），即使没有用到这两个 props。

而这种情况下，`ChildMemo.js` 则不会重新进行 re-render。

只有当 props.number 发生变化的时候，`ChildMemo.js` 和 `Child.js` 表现是一致的。

从上面可以看出，**React.memo() 的第二个方法在某种特定需求下，是必须存在的。** 因为在实验的场景中，我们能够看得出来，即使我使用 `React.memo` 包装了 Child.js，也会一直触发重新渲染，因为 props 浅比较肯定是发生了变化。

## useMemo

上面 React.memo() 的使用我们可以发现，最终都是在最外层包装了整个组件，并且需要手动写一个方法比较那些具体的 props 不相同才进行 re-render。

而在某些场景下，**我们只是希望 component 的部分不要进行 re-render，而不是整个 component 不要 re-render，也就是要实现 `局部 Pure` 功能。**

```text
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

useMemo() 返回的是一个 memoized 值，只有当依赖项（比如上面的 a,b 发生变化的时候，才会重新计算这个 memoized 值）memoized 值不变的情况下，不会重新触发渲染逻辑。

说起渲染逻辑，**需要记住的是 useMemo() 是在 render 期间执行的，所以不能进行一些额外的副操作**，比如网络请求等。

如果没有提供依赖数组（上面的 [a,b]）则每次都会重新计算 memoized 值，也就会 re-redner

上面的代码中新增一个 `Child-useMemo.js` 子组件如下：

```jsx
import React, { useMemo } from 'react';

export default (props ) => {
    console.log(`--- component re-render ---`);
    return useMemo(() => {
        console.log(`--- useMemo re-render ---`);
        return <div>
            {/* <p>step is : {props.step}</p> */}
            {/* <p>count is : {props.count}</p> */}
            <p>number is : {props.number}</p>
        </div>
    }, [props.number]);
}

```

我们在index.jsx中引用child和childUseMemo

<img src="https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/123.gif" style="zoom: 100%"></img>

上面图中我们可以发现，父组件每次更新 step/count 都会触发 useMemo 封装的子组件的 re-render，但是 number 没有变化，说明并没有重新触发 HTML 部分 re-render

只有当依赖的 props.number 发生变化的时候，才会重新触发 useMemo() 包装的里面的 re-render

# 3.react-redux中替代connect方案

传送门：

[redux中使用useSelector、useDispatch替代connect - 掘金 (juejin.cn)](https://juejin.cn/post/6918685722229063688)

[react-redux@7.1.0 useSelector: 别啦 connect - 掘金 (juejin.cn)](https://juejin.cn/post/6844903874197880840)

## 1.useSelector



## 2.替代connect方案



# 4.千锋视频

传送门：

[千锋2022版React全家桶教程_react零基础入门到项目实战完整版_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1dP4y1c7qd?p=1)

我发现这个视频有很多新知识，学学。

### 1-setState同步异步

-   setState处在同步的逻辑中，  异步更新状态，异步更新真实dom
-   setState处在异步的逻辑中，  同步更新状态，同步更新真实dom
-   setState 接受第二个参数， 第二个参数式回调函数， 状态和dom更新完后就会被触发。

在18版本里 setState处在异步的逻辑中，  异步更新状态，异步更新真实dom

```js
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        count: 1
    }
    render() {
        return (
            <div>
                {this.state.count}
                <button onClick={this.handleAdd1}>add1</button>
                <button onClick={this.handleAdd2}>add2</button>
            </div>
        )
    }
	//同步逻辑
    handleAdd1 = () => {
        this.setState({
            count: this.state.count + 1
        })

        console.log(this.state.count)

        this.setState({
            count: this.state.count + 1
        }, () => {
            console.log(this.state.count)
        })


        this.setState({
            count: this.state.count + 1
        }, () => {
            console.log(this.state.count)
            // 状态 和真实dom已经更新完了，
        })

        console.log('-------------------')
    }
	//异步逻辑
    handleAdd2 = () => {
        setTimeout(() => {
            this.setState({
                count: this.state.count + 1
            })

            console.log(this.state.count)

            this.setState({
                count: this.state.count + 1
            })

            console.log(this.state.count)

            this.setState({
                count: this.state.count + 1
            })
            console.log(this.state.count)
            console.log('-------------------')
        }, 0)

    }
}

```

同步逻辑：

只执行了1个setState

<img src="https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/144.gif" style="zoom: 100%"></img>

异步逻辑：

3个setState都执行了

<img src="https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/145.gif" style="zoom: 100%"></img>

### 2.betterScroll

BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。

BetterScroll 是使用纯 JavaScript 实现的，这意味着它是无依赖的。

传送门：

[better-scroll/README_zh-CN.md at master · ustbhuangyi/better-scroll (github.com)](https://github.com/ustbhuangyi/better-scroll/blob/master/README_zh-CN.md)



```js
import React, { Component } from 'react'
import BetterScroll from 'better-scroll'

export default class App extends Component {
    state = {
        list:[]
    }
    render() {
        return (
            <div>
                <button onClick={()=>this.getData()}>click</button>
//盒子高度装不下子内容
                <div className="kerwinwrapper" style=		{{height:'200px',background:'yellow',overflow:'hidden'}}>
                    <ul className="kerwincontent">
                       {
                           this.state.list.map(item=>
                           <li key={item}>{item}</li>
                            )
                       }
                    </ul>
                </div>
            </div>
        )
    }
    getData(){
        var list =[1,2,3,4,5,6,7,8,9,0,11,12,13,14,15]
        this.setState({
            list:list
        },()=>{
            //一定是dom节点更新完再创建喔
            new BetterScroll(".kerwinwrapper")
        })
    }
}
```

<img src="https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/146.gif" style="zoom: 100%"></img>



### 3.插槽

```jsx
/*
 * @作者: kerwin
 * @公众号: 大前端私房菜
 */
import React, { Component } from 'react'

class Child extends Component{
    render(){
        return <div>
            child
            {/* 插槽 vue slot,具名插槽 */}

            {this.props.children[2]}
            {this.props.children[1]}
            {this.props.children[0]}
        </div>
    }
}

class Swiper extends Component{
    render(){
        return <div>
            {this.props.children}
        </div>
    }
}

export default class App extends Component {
    render() {
        return (
            <div>

                <Swiper>
                    <div>111111</div>
                    <div>222222</div>
                    <div>333333</div>
                </Swiper>

                
                <Child>
                    <div>11111111</div>
                    <div>22222222</div>
                    <div>33333333</div>
                </Child>
            </div>
        )
    }
}

```

![image-20220502194230160](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220502194230160.png)

### 4.immutable

传送门：

[15 分钟学会 Immutable - 掘金 (juejin.cn)](https://juejin.cn/post/6976798974757830687)

npm：

有很多例子

[immutable - npm (npmjs.com)](https://www.npmjs.com/package/immutable)

#### 1.map

深复制

```js
import { Map } from 'immutable'

var user = {
    name: "小冯",
    age: 100
}

var oldImmUser = Map(user)
var newImmUser = oldImmUser.set("name", '大冯')
console.log(oldImmUser,newImmUser)
```

![image-20220502205243650](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220502205243650.png)

获取对象属性

```js
//1 get获取immutalble 

console.log(oldImmUser.get('name'),newImmUser.get('name'))

//2 immutable===>普通对象

console.log(oldImmUser.toJS(), newImmUser.toJS())
```

![image-20220502205709566](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220502205709566.png)

#### 2.List

```js
import {List} from 'immutable'
var arr = List([1,2,3])
//不会影响老的对象结构
var arr2 = arr.push(4) 
var arr3 = arr2.concat([5,6,7])
console.log(arr,arr2,arr3)
console.log(arr.toJS(),arr2.toJS(),arr3.toJS())

```

![image-20220502211655302](https://picture-feng.oss-cn-chengdu.aliyuncs.com/img/image-20220502211655302.png)

#### 3.fromJS

复杂对象，不知道直接用fromJS。他会自动把对象用Map转，数组用List转

```js
let person=fromJS({
    name:"kerwin",
    location:{
        province:"辽宁",
        city:"大连"
    },
    favor:["读书","看报","写代码"]
})

console.log(person)
let newPerson = person.set('name','小冯')//相当于把姓名转成‘小冯’
    .setIn(['location','province'],'四川')//把location下的province改成四川
    .setIn(['location','city'],'成都')
console.log(newPerson)
```

我们用setIn可以指定修改层级，也可以链式调用



还可以用updateIn对深层次元素进行操作

```js
let person=fromJS({
    name:"kerwin",
    location:{
        province:"辽宁",
        city:"大连"
    },
    favor:["读书","看报","写代码"]
})

//这里就删除了'写代码'这一项
let newPerson_1 = person.updateIn(['favor'],(list)=>list.splice(2,1))
console.log(newPerson_1)
```

### 5.forwardRef

可以在自定义组件上使用ref,实现ref穿透。

和withRouter很像，都是HOC高阶组件

```js
/*
 * @作者: kerwin
 * @公众号: 大前端私房菜
 */
import React, { Component, forwardRef } from 'react'

export default class App extends Component {
    mytext =React.createRef()

    render() {
        return (
            <div>
                <button onClick={()=>{
                    console.log(this.mytext)
                    this.mytext.current.value=""
                    this.mytext.current.focus()
                }}>获取焦点</button>

                <Child ref={this.mytext}/>
            </div>
        )
    }
}

const Child = forwardRef((props,ref)=>{
    return <div style={{background:"red"}}>
        <input ref={ref} defaultValue="22222"/>
    </div>
})
```

